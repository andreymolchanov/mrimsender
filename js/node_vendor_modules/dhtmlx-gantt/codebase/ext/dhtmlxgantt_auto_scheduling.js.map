{"version":3,"sources":["webpack:///dhtmlxgantt_auto_scheduling.js","webpack:///webpack/bootstrap 9278c35520642ffbe1b9","webpack:///./sources/core/links_common.js","webpack:///./sources/ext/auto_scheduling.js","webpack:///./sources/utils/helpers.js"],"names":["Gantt","plugin","gantt","modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_get_linked_task","link","getTarget","task","taskId","target","source","isTaskExists","getTask","_get_link_target","_get_link_source","caching","formattedLinksStash","inheritedSuccessorsStash","inheritedPredecessorsStash","getPredecessorsCache","_isLinksCacheEnabled","_startLinksCache","_endLinksCache","_formatLink","id","relations","this","isSummaryTask","isChildOf","from","_getImplicitLinks","respectTargetOffset","config","auto_scheduling_move_projects","targetDates","getSubtaskDates","start_date","end_date","to","$target","length","getState","drag_id","calculateDuration","fromLength","fromTask","j","toLength","toTask","lag","subtaskLink","type","push","_convertToFinishToStartLink","taskParent","_isAutoSchedulable","auto_scheduling","parent","selectOffset","selectSourceLinks","children","eachTask","skipChild","linksCollection","$source","siblingLink","getLink","siblingId","_getDirectDependencies","selectSuccessors","links","successors","linksIds","concat","_getInheritedDependencies","cacheCollection","stop","inheritedRelations","getParent","eachParent","apply","parentDependencies","_getDirectSuccessors","_getInheritedSuccessors","_getDirectPredecessors","_getInheritedPredecessors","_getSuccessors","skipInherited","_getPredecessors","result","key","predecessors","sourceTask","targetTask","sourceParent","targetParent","res","finish_to_start","preferredStart","additionalLag","start_to_start","duration","finish_to_finish","start_to_finish","auto_scheduling_descendant_links","auto_scheduling_initial","auto_scheduling_strict","helpers","_autoSchedulingGraph","getVertices","rel","ids","len","vertices","topologicalSort","edges","hash","$incoming","successor","S","filter","v","L","pop","node","_groupEdgesBySource","edge","tarjanStronglyConnectedComponents","strongConnect","vertexId","previousLink","getVertex","index","lowLink","connectedEdges","onStack","edgesFromTasks","e","w","undefined","Math","min","connectedComponent","tasks","connectedComponents","verticesHash","_autoSchedulingPath","getKey","getVirtualRoot","mixin","root_id","types","project","$virtual","filterDuplicates","keys","splice","getLinkedTasks","includePredecessors","startIds","clearCache","visited","_getLinkedTasks","rootTask","visitedTasks","isChild","rootObj","linkKey","isSameParent","hasChild","getChildren","findLoops","cycles","forEach","graph","component","_autoSchedulingDateResolver","isFirstSmaller","small","big","valueOf","_hasDuration","isSmallerOrDefault","smallDate","bigDate","resolveRelationDate","getEndDate","minStart","linkId","defaultStart","relation","constraintDate","getConstraintDate","getClosestWorkTime","date","dir","predecessorEnd","successorStart","calculateEndDate","_autoSchedulingPlanner","generatePlan","getPredecessorEndDate","plan","plansHash","orderedIds","predecessorRelations","dateResolver","currentId","isLinkExists","predecessor","callEvent","applyProjectPlan","projectPlan","updateTasks","newDate","_autoSchedulingPreferredDates","startTask","Date","_autoSchedule","updateCallback","_autoscheduling_in_progress","path","updatedTasks","planner","autoSchedule","inclusive","startAutoSchedule","now","_finalizeAutoSchedulingChanges","resetTime","batchUpdate","start","end","resetProjectDates","payload","updateTask","isCircularLink","_getConnectedGroup","manager","allRelations","findCycles","_attachAutoSchedulingHandlers","resetToStartLinksLags","skipped","originalLink","presentLinks","updatedLinks","_autoScheduleAfterLinkChange","attachEvent","_preventCircularLink","_preventDescendantLink","_datesNotEqual","dateA","dateB","taskA","taskB","_notEqualTaskDates","task1","task2","milestone","movedTask","mode","_autoScheduleAfterDND","newTask","_lightBoxChangesHandler","oldTask","_autoschedule_lightbox_id","_lightBoxSaveHandler","getSecondsInUnit","unit","units","hour","arr","callback","workArray","slice","arrayMap","map","resArray","second","minute","day","week","month","quarter","year"],"mappings":"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","file":"dhtmlxgantt_auto_scheduling.js","sourcesContent":["/*!\n * @license\r\n * \r\n * dhtmlxGantt v.5.1.5 Professional\r\n * This software is covered by DHTMLX Enterprise License. Usage without proper license is prohibited.\r\n * \r\n * (c) Dinamenta, UAB.\r\n * \n */\nGantt.plugin(function(gantt){\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 2);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */,\n/* 1 */\n/***/ (function(module, exports) {\n\nmodule.exports = function(gantt) {\r\n// helpers for building chain of dependencies, used for critical path calculation and for auto scheduling\r\n\r\n\tgantt._get_linked_task = function (link, getTarget) {\r\n\t\tvar task = null;\r\n\t\tvar taskId = getTarget ? link.target : link.source;\r\n\r\n\t\tif (gantt.isTaskExists(taskId)) {\r\n\t\t\ttask = gantt.getTask(taskId);\r\n\t\t}\r\n\r\n\t\treturn task;\r\n\t};\r\n\tgantt._get_link_target = function (link) {\r\n\t\treturn gantt._get_linked_task(link, true);\r\n\t};\r\n\r\n\tgantt._get_link_source = function (link) {\r\n\t\treturn gantt._get_linked_task(link, false);\r\n\t};\r\n\r\n\tvar caching = false;\r\n\tvar formattedLinksStash = {};\r\n\tvar inheritedSuccessorsStash = {};\r\n\tvar inheritedPredecessorsStash = {};\r\n\tvar getPredecessorsCache = {};\r\n\r\n\r\n\tgantt._isLinksCacheEnabled = function(){\r\n\t\treturn caching;\r\n\t};\r\n\tgantt._startLinksCache = function(){\r\n\t\tformattedLinksStash = {};\r\n\t\tinheritedSuccessorsStash = {};\r\n\t\tinheritedPredecessorsStash = {};\r\n\t\tgetPredecessorsCache = {};\r\n\t\tcaching = true;\r\n\t};\r\n\tgantt._endLinksCache = function(){\r\n\t\tformattedLinksStash = {};\r\n\t\tinheritedSuccessorsStash = {};\r\n\t\tinheritedPredecessorsStash = {};\r\n\t\tgetPredecessorsCache = {};\r\n\t\tcaching = false;\r\n\t};\r\n\r\n\tgantt._formatLink = function (link) {\r\n\r\n\r\n\t\tif(caching && formattedLinksStash[link.id]){\r\n\t\t\treturn formattedLinksStash[link.id];\r\n\t\t}\r\n\r\n\t\tvar relations = [];\r\n\t\tvar target = this._get_link_target(link);\r\n\t\tvar source = this._get_link_source(link);\r\n\r\n\t\tif (!(source && target)) {\r\n\t\t\treturn relations;\r\n\t\t}\r\n\r\n\t\tif ((gantt.isSummaryTask(target) && gantt.isChildOf(source.id, target.id)) || (gantt.isSummaryTask(source) && gantt.isChildOf(target.id, source.id))) {\r\n\t\t\treturn relations;\r\n\t\t}\r\n\r\n\r\n\t\t// there are three kinds of connections at this point\r\n\t\t// task -> task - regular link\r\n\t\t// task -> project - transform it into set of regular links (task -> [each subtask]), use offset beetween subtask and project dates as lag, in order not to change mutual positions of subtasks inside a project\r\n\t\t// project -> task - transform it into ([each subtask] -> task) links\r\n\t\t// project -> project - transform it into ([each subtask of p1] -> [each subtask of p2]) links\r\n\r\n\t\tvar from = this._getImplicitLinks(link, source, function (c) {\r\n\t\t\treturn 0;\r\n\t\t}, true);\r\n\r\n\t\tvar respectTargetOffset = gantt.config.auto_scheduling_move_projects;\r\n\t\tvar targetDates = this.isSummaryTask(target) ? this.getSubtaskDates(target.id) : {\r\n\t\t\tstart_date: target.start_date,\r\n\t\t\tend_date: target.end_date\r\n\t\t};\r\n\t\tvar to = this._getImplicitLinks(link, target, function (c) {\r\n\t\t\tif (!respectTargetOffset) {\r\n\t\t\t\treturn 0;\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif (!c.$target.length && !(gantt.getState().drag_id == c.id)) {// drag_id - virtual lag shouldn't restrict task that is being moved inside project\r\n\t\t\t\t\treturn gantt.calculateDuration({\r\n\t\t\t\t\t\tstart_date: targetDates.start_date,\r\n\t\t\t\t\t\tend_date: c.start_date,\r\n\t\t\t\t\t\ttask: source\r\n\t\t\t\t\t});\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn 0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tfor (var i = 0, fromLength = from.length; i < fromLength; i++) {\r\n\t\t\tvar fromTask = from[i];\r\n\t\t\tfor (var j = 0, toLength = to.length; j < toLength; j++) {\r\n\t\t\t\tvar toTask = to[j];\r\n\r\n\t\t\t\tvar lag = fromTask.lag * 1 + toTask.lag * 1;\r\n\r\n\t\t\t\tvar subtaskLink = {\r\n\t\t\t\t\tid: link.id,\r\n\t\t\t\t\ttype: link.type,\r\n\t\t\t\t\tsource: fromTask.task,\r\n\t\t\t\t\ttarget: toTask.task,\r\n\t\t\t\t\tlag: (link.lag * 1 || 0) + lag\r\n\t\t\t\t};\r\n\r\n\t\t\t\trelations.push(gantt._convertToFinishToStartLink(toTask.task, subtaskLink, source, target, fromTask.taskParent, toTask.taskParent));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif(caching)\r\n\t\t\tformattedLinksStash[link.id] = relations;\r\n\r\n\t\treturn relations;\r\n\t};\r\n\r\ngantt._isAutoSchedulable = function(task){\r\n\treturn task.auto_scheduling !== false;\r\n};\r\n\r\ngantt._getImplicitLinks = function(link, parent, selectOffset, selectSourceLinks){\r\n\tvar relations = [];\r\n\r\n\tif(this.isSummaryTask(parent)){\r\n\r\n\t\t// if the summary task contains multiple chains of linked tasks - no need to consider every task of the chain,\r\n\t\t// it will be enough to check the first/last tasks of the chain\r\n\t\t// special conditions if there are unscheduled tasks in the chain, or negative lag values\r\n\t\tvar children = {};\r\n\t\tthis.eachTask(function(c){\r\n\t\t\tif(!this.isSummaryTask(c)){\r\n\t\t\t\tchildren[c.id] = c;\r\n\t\t\t}\r\n\t\t}, parent.id);\r\n\r\n\t\tvar skipChild;\r\n\r\n\t\tfor(var c in children){\r\n\t\t\tvar task = children[c];\r\n\t\t\tvar linksCollection = selectSourceLinks ? task.$source : task.$target;\r\n\r\n\t\t\tskipChild = false;\r\n\r\n\t\t\tfor(var l = 0; l < linksCollection.length; l++){\r\n\t\t\t\tvar siblingLink = gantt.getLink(linksCollection[l]);\r\n\t\t\t\tvar siblingId = selectSourceLinks ? siblingLink.target : siblingLink.source;\r\n\r\n\t\t\t\tif(children[siblingId] && task.auto_scheduling !== false && children[siblingId].auto_scheduling !== false && siblingLink.lag >= 0){\r\n\t\t\t\t\tskipChild = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(!skipChild){\r\n\t\t\t\trelations.push({task: task.id, taskParent: task.parent, lag: selectOffset(task)});\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}else{\r\n\t\trelations.push({task:parent.id, taskParent: parent.parent, lag: 0});\r\n\t}\r\n\r\n\t\treturn relations;\r\n};\r\n\r\n\tgantt._getDirectDependencies = function (task, selectSuccessors) {\r\n\r\n\t\tvar links = [],\r\n\t\t\tsuccessors = [];\r\n\r\n\t\tvar linksIds = selectSuccessors ? task.$source : task.$target;\r\n\r\n\tfor(var i = 0; i < linksIds.length; i++){\r\n\t\tvar link = this.getLink(linksIds[i]);\r\n\t\tif(this.isTaskExists(link.source) && this.isTaskExists(link.target)) {\r\n\t\t\tvar target = this.getTask(link.target);\r\n\t\t\tif(this._isAutoSchedulable(target)){\r\n\t\t\t\tlinks.push(this.getLink(linksIds[i]));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t\tfor (var i = 0; i < links.length; i++) {\r\n\t\t\tsuccessors = successors.concat(this._formatLink(links[i]));\r\n\t\t}\r\n\r\n\t\treturn successors;\r\n\t};\r\n\r\n\tgantt._getInheritedDependencies = function (task, selectSuccessors) {\r\n\r\n\t\t//var successors = [];\r\n\tvar stop = false;\r\n\tvar inheritedRelations = [];\r\n\tvar cacheCollection;\r\n\tif(this.isTaskExists(task.id)){\r\n\r\n\t\tvar parent = this.getParent(task.id);\r\n\r\n\r\n\t\tthis.eachParent(function(parent){\r\n\t\t\tif(stop)\r\n\t\t\t\treturn;\r\n\r\n\t\t\tif(caching){\r\n\t\t\t\tcacheCollection = selectSuccessors ? inheritedSuccessorsStash : inheritedPredecessorsStash;\r\n\t\t\t\tif(cacheCollection[parent.id]){\r\n\t\t\t\t\tinheritedRelations.push.apply(inheritedRelations, cacheCollection[parent.id]);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tvar parentDependencies;\r\n\t\t\tif(this.isSummaryTask(parent)){\r\n\t\t\t\tif(!this._isAutoSchedulable(parent)){\r\n\t\t\t\t\tstop = true;\r\n\t\t\t\t}else{\r\n\t\t\t\t\tparentDependencies = this._getDirectDependencies(parent, selectSuccessors);\r\n\t\t\t\t\tif(caching){\r\n\t\t\t\t\t\tcacheCollection[parent.id] = parentDependencies;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tinheritedRelations.push.apply(inheritedRelations, parentDependencies);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t}, task.id, this);\r\n\r\n\t\t//\tfor (var i = 0; i < inheritedRelations.length; i++) {\r\n\t\t//\t\tsuccessors.push(inheritedRelations[i]);\r\n\t\t//\t}\r\n\t\t}\r\n\r\n\t\treturn inheritedRelations;\r\n\t};\r\n\r\n\r\n\tgantt._getDirectSuccessors = function (task) {\r\n\t\treturn this._getDirectDependencies(task, true);\r\n\t};\r\n\r\n\tgantt._getInheritedSuccessors = function (task) {\r\n\t\treturn this._getInheritedDependencies(task, true);\r\n\t};\r\n\r\n\tgantt._getDirectPredecessors = function (task) {\r\n\t\treturn this._getDirectDependencies(task, false);\r\n\t};\r\n\r\n\tgantt._getInheritedPredecessors = function (task) {\r\n\t\treturn this._getInheritedDependencies(task, false);\r\n\t};\r\n\r\n\tgantt._getSuccessors = function (task, skipInherited) {\r\n\t\tvar successors = this._getDirectSuccessors(task);\r\n\t\tif(skipInherited){\r\n\t\t\treturn successors;\r\n\t\t}else{\r\n\t\t\treturn successors.concat(this._getInheritedSuccessors(task));\r\n\t\t}\r\n\t};\r\n\r\n\tgantt._getPredecessors = function (task, skipInherited) {\r\n\t\tvar key = task.id + skipInherited;\r\n\t\tvar result;\r\n\r\n\t\tif(caching && getPredecessorsCache[key]){\r\n\t\t\treturn getPredecessorsCache[key];\r\n\t\t}\r\n\r\n\t\tvar predecessors = this._getDirectPredecessors(task);\r\n\t\tif(skipInherited){\r\n\t\t\tresult = predecessors;\r\n\t\t}else{\r\n\t\t\tresult = predecessors.concat(this._getInheritedPredecessors(task));\r\n\t\t}\r\n\t\tif(caching){\r\n\t\t\tgetPredecessorsCache[key] = result;\r\n\t\t}\r\n\t\treturn result;\r\n\t};\r\n\r\n\r\n\tgantt._convertToFinishToStartLink = function (id, link, sourceTask, targetTask, sourceParent, targetParent) {\r\n\t\t// convert finish-to-finish, start-to-finish and start-to-start to finish-to-start link and provide some additional properties\r\n\t\tvar res = {\r\n\t\t\ttarget: id,\r\n\t\t\tlink: gantt.config.links.finish_to_start,\r\n\t\t\tid: link.id,\r\n\t\t\tlag: link.lag || 0,\r\n\t\t\tsource: link.source,\r\n\t\t\tpreferredStart: null,\r\n\t\t\tsourceParent: sourceParent,\r\n\t\t\ttargetParent: targetParent\r\n\t\t};\r\n\r\n\t\tvar additionalLag = 0;\r\n\t\tswitch (link.type) {\r\n\t\t\tcase gantt.config.links.start_to_start:\r\n\t\t\t\tadditionalLag = -sourceTask.duration;\r\n\t\t\t\tbreak;\r\n\t\t\tcase gantt.config.links.finish_to_finish:\r\n\t\t\t\tadditionalLag = -targetTask.duration;\r\n\t\t\t\tbreak;\r\n\t\t\tcase gantt.config.links.start_to_finish:\r\n\t\t\t\tadditionalLag = -sourceTask.duration - targetTask.duration;\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tadditionalLag = 0;\r\n\t\t}\r\n\r\n\t\tres.lag += additionalLag;\r\n\t\treturn res;\r\n\t};\r\n};\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(3);\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(1)(gantt);\r\n\r\ngantt.config.auto_scheduling = false;\r\ngantt.config.auto_scheduling_descendant_links = false;\r\ngantt.config.auto_scheduling_initial = true;\r\ngantt.config.auto_scheduling_strict = false;\r\ngantt.config.auto_scheduling_move_projects = true;\r\n\r\n(function(){\r\n\r\nvar helpers = __webpack_require__(4);\r\n\r\n\r\ngantt._autoSchedulingGraph = {\r\n\tgetVertices: function(relations){\r\n\t\tvar ids = {};\r\n\t\tvar rel;\r\n\t\tfor(var i = 0, len = relations.length; i < len; i++){\r\n\t\t\trel = relations[i];\r\n\t\t\tids[rel.target] = rel.target;\r\n\t\t\tids[rel.source] = rel.source;\r\n\t\t}\r\n\r\n\t\tvar vertices = [];\r\n\t\tvar id;\r\n\t\tfor(var i in ids){\r\n\t\t\tid = ids[i];\r\n\t\t\tvertices.push(id);\r\n\t\t}\r\n\r\n\t\treturn vertices;\r\n\t},\r\n\ttopologicalSort: function(edges){\r\n\t\tvar vertices = this.getVertices(edges);\r\n\t\tvar hash = {};\r\n\r\n\t\tfor(var i = 0, len = vertices.length; i < len; i ++){\r\n\t\t\thash[vertices[i]] = {id: vertices[i], $source:[], $target:[], $incoming: 0};\r\n\t\t}\r\n\r\n\t\tfor(var i = 0, len = edges.length; i < len; i++){\r\n\t\t\tvar successor = hash[edges[i].target];\r\n\t\t\tsuccessor.$target.push(i);\r\n\t\t\tsuccessor.$incoming = successor.$target.length;\r\n\t\t\thash[edges[i].source].$source.push(i);\r\n\r\n\t\t}\r\n\r\n\t\t// topological sort, Kahn's algorithm\r\n\t\tvar S = vertices.filter(function(v){ return !hash[v].$incoming; });\r\n\r\n\t\tvar L = [];\r\n\r\n\t\twhile(S.length){\r\n\t\t\tvar n = S.pop();\r\n\r\n\t\t\tL.push(n);\r\n\r\n\t\t\tvar node = hash[n];\r\n\r\n\t\t\tfor(var i = 0; i < node.$source.length; i++){\r\n\t\t\t\tvar m = hash[edges[node.$source[i]].target];\r\n\t\t\t\tm.$incoming--;\r\n\t\t\t\tif(!m.$incoming){\r\n\t\t\t\t\tS.push(m.id);\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn L;\r\n\r\n\t},\r\n\t_groupEdgesBySource: function(edges){\r\n\t\tvar res = {};\r\n\t\tvar edge;\r\n\t\tfor(var i = 0, len = edges.length; i < len; i++){\r\n\t\t\tedge = edges[i];\r\n\t\t\tif(!res[edge.source]){\r\n\t\t\t\tres[edge.source] = [];\r\n\t\t\t}\r\n\t\t\tres[edge.source].push(edge);\r\n\t\t}\r\n\t\treturn res;\r\n\t},\r\n\ttarjanStronglyConnectedComponents: function(vertices, edges){\r\n\t\t//https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\r\n\t\tvar verticesHash = {};\r\n\r\n\t\tvar index = 0;\r\n\t\tvar S = [];\r\n\t\tvar connectedEdges = [];\r\n\t\tvar connectedComponents = [];\r\n\r\n\t\tvar edgesFromTasks = this._groupEdgesBySource(edges);\r\n\r\n\t\tvar vertexId;\r\n\t\tfor(var v = 0, len = vertices.length; v < len; v++){\r\n\t\t\tvertexId = vertices[v];\r\n\t\t\tvar vertex = getVertex(vertexId);\r\n\t\t\tif(vertex.index === undefined){\r\n\t\t\t\tstrongConnect(vertexId);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction strongConnect(vertexId, previousLink){\r\n\t\t\tvar v = getVertex(vertexId);\r\n\t\t\tv.index = index;\r\n\t\t\tv.lowLink = index;\r\n\t\t\tindex++;\r\n\r\n\t\t\tif(previousLink){\r\n\t\t\t\tconnectedEdges.push(previousLink);\r\n\t\t\t}\r\n\r\n\t\t\tS.push(v);\r\n\t\t\tv.onStack = true;\r\n\r\n\t\t\t// Consider successors of v\r\n\r\n\t\t\tvar edge;\r\n\t\t\tvar successors = edgesFromTasks[vertexId];\r\n\t\t\tfor(var e = 0; successors  && e < successors.length; e++){\r\n\t\t\t\tedge = successors[e];\r\n\t\t\t\tif(edge.source != vertexId) continue;\r\n\r\n\t\t\t\tvar v = getVertex(edge.source);\r\n\t\t\t\tvar w = getVertex(edge.target);\r\n\t\t\t\tif(w.index === undefined){\r\n\t\t\t\t\t// Successor w has not yet been visited; recurse on it\r\n\t\t\t\t\tstrongConnect(edge.target, edge);\r\n\t\t\t\t\tv.lowLink = Math.min(v.lowLink, w.lowLink);\r\n\t\t\t\t}else if(w.onStack){\r\n\t\t\t\t\t// Successor w is in stack S and hence in the current SCC\r\n\t\t\t\t\tv.lowLink = Math.min(v.lowLink, w.index);\r\n\t\t\t\t\tconnectedEdges.push(edge);\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// If v is a root node, pop the stack and generate an SCC\r\n\t\t\tif(v.lowLink == v.index){\r\n\t\t\t\tvar connectedComponent = {tasks: [], links:[]};\r\n\t\t\t\tvar w;\r\n\t\t\t\tdo{\r\n\t\t\t\t\tvar rel = connectedEdges.pop();\r\n\t\t\t\t\tw = S.pop();\r\n\t\t\t\t\tw.onStack = false;\r\n\t\t\t\t\tconnectedComponent.tasks.push(w.id);\r\n\t\t\t\t\tif(rel){\r\n\t\t\t\t\t\tconnectedComponent.links.push(rel.id);\r\n\t\t\t\t\t}\r\n\t\t\t\t}while(w.id != v.id);\r\n\t\t\t\tconnectedComponents.push(connectedComponent);\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn connectedComponents;\r\n\r\n\t\tfunction getVertex(id){\r\n\t\t\tif(!verticesHash[id]){\r\n\t\t\t\tverticesHash[id] = {id: id, onStack:false, index: undefined, lowLink: undefined};\r\n\t\t\t}\r\n\r\n\t\t\treturn verticesHash[id];\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\ngantt._autoSchedulingPath = {\r\n\tgetKey: function(rel){\r\n\t\treturn rel.lag +\"_\"+ rel.link +\"_\"+ rel.source +\"_\"+ rel.target;\r\n\t},\r\n\tgetVirtualRoot: function(){\r\n\t\treturn gantt.mixin(\r\n\t\t\tgantt.getSubtaskDates(),\r\n\t\t\t{\r\n\t\t\t\tid: gantt.config.root_id,\r\n\t\t\t\ttype: gantt.config.types.project,\r\n\t\t\t\t$source: [],\r\n\t\t\t\t$target: [],\r\n\t\t\t\t$virtual: true\r\n\t\t\t}\r\n\t\t);\r\n\t},\r\n\r\n\tfilterDuplicates: function(relations){\r\n\t\tvar keys = {};\r\n\t\tfor(var i = 0; i < relations.length; i++){\r\n\t\t\tvar key = this.getKey(relations[i]);\r\n\t\t\tif(keys[key]){\r\n\t\t\t\trelations.splice(i, 1);\r\n\t\t\t\ti--;\r\n\t\t\t}else{\r\n\t\t\t\tkeys[key] = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn relations;\r\n\t},\r\n\r\n\tgetLinkedTasks: function(id, includePredecessors){\r\n\t\tvar startIds = [id];\r\n\r\n\t\t//TODO: format links cache\r\n\t\tvar clearCache = false;\r\n\t\tif(!gantt._isLinksCacheEnabled()) {\r\n\t\t\tgantt._startLinksCache();\r\n\t\t\tclearCache = true;\r\n\t\t}\r\n\t\tvar relations = [];\r\n\t\tvar visited = {};\r\n\t\tfor(var i = 0; i < startIds.length; i++){\r\n\t\t\tthis._getLinkedTasks(startIds[i], visited, includePredecessors);\r\n\t\t}\r\n\r\n\t\tfor(var i in visited){\r\n\t\t\trelations.push(visited[i]);\r\n\t\t}\r\n\t\tif(clearCache)\r\n\t\t\tgantt._endLinksCache();\r\n\t\treturn relations;\r\n\t},\r\n\r\n\t_getLinkedTasks: function(rootTask, visitedTasks, includePredecessors, isChild) {\r\n\t\tvar from = rootTask === undefined ? gantt.config.root_id : rootTask;\r\n\t\tvar visited = visitedTasks || {};\r\n\r\n\t\tvar rootObj = gantt.isTaskExists(from) ? gantt.getTask(from) : this.getVirtualRoot();\r\n\r\n\t\tvar successors = gantt._getSuccessors(rootObj, isChild);\r\n\r\n\t\tvar predecessors = [];\r\n\t\tif (includePredecessors) {\r\n\t\t\tpredecessors = gantt._getPredecessors(rootObj, isChild);\r\n\t\t}\r\n\t\tvar relations = [];\r\n\t\tvar linkKey;\r\n\r\n\t\tfor(var i = 0; i < successors.length; i++){\r\n\t\t\tlinkKey = this.getKey(successors[i]);\r\n\t\t\tif(visited[linkKey]) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}else{\r\n\t\t\t\tvisited[linkKey] = successors[i];\r\n\t\t\t\trelations.push(successors[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor(var i = 0; i < predecessors.length; i++){\r\n\t\t\tlinkKey = this.getKey(predecessors[i]);\r\n\t\t\tif(visited[linkKey]) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}else{\r\n\t\t\t\tvisited[linkKey] = predecessors[i];\r\n\t\t\t\trelations.push(predecessors[i]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor(var i=0; i < relations.length; i++){\r\n\t\t\tvar isSameParent = relations[i].sourceParent == relations[i].targetParent;\r\n\t\t\tthis._getLinkedTasks(relations[i].target, visited, true, isSameParent);\r\n\t\t}\r\n\r\n\t\tif(gantt.hasChild(rootObj.id)){\r\n\t\t\tvar children = gantt.getChildren(rootObj.id);\r\n\t\t\tfor(var i=0; i < children.length; i++){\r\n\t\t\t\tthis._getLinkedTasks(children[i], visited, true, true);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn relations;\r\n\t},\r\n\r\n\tfindLoops: function(relations){\r\n\r\n\t\tvar cycles = [];\r\n\r\n\t\thelpers.forEach(relations, function(rel){\r\n\t\t\tif(rel.target == rel.source)\r\n\t\t\t\tcycles.push([rel.target, rel.source]);\r\n\t\t});\r\n\r\n\t\tvar graph =  gantt._autoSchedulingGraph;\r\n\t\tvar vertices = graph.getVertices(relations);\r\n\r\n\t\tvar connectedComponents = graph.tarjanStronglyConnectedComponents(vertices, relations);\r\n\r\n\t\thelpers.forEach(connectedComponents, function(component){\r\n\t\t\tif(component.tasks.length > 1){\r\n\t\t\t\tcycles.push(component);//{ tasks: [task ids], links: [links ids]}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn cycles;\r\n\t\t//{task:id, link:link.type, lag: link.lag || 0, source: link.source}\r\n\t}\r\n};\r\n\r\ngantt._autoSchedulingDateResolver = {\r\n\tisFirstSmaller: function(small, big, task){\r\n\t\tif(small.valueOf() < big.valueOf() && gantt._hasDuration(small, big, task))\r\n\t\t\treturn true;\r\n\t\treturn false;\r\n\t},\r\n\r\n\tisSmallerOrDefault: function(smallDate, bigDate, task){\r\n\t\treturn !!(!smallDate || this.isFirstSmaller(smallDate, bigDate, task));\r\n\t},\r\n\r\n\tresolveRelationDate: function(taskId, relations, getEndDate){\r\n\t\tvar minStart = null;\r\n\t\tvar linkId = null;\r\n\r\n\t\tvar defaultStart = null;\r\n\t\tvar task;\r\n\t\tfor(var i = 0; i < relations.length; i++){\r\n\t\t\tvar relation = relations[i];\r\n\t\t\ttaskId = relation.target;\r\n\r\n\t\t\tdefaultStart = relation.preferredStart;\r\n\t\t\ttask = gantt.getTask(taskId);\r\n\t\t\tvar constraintDate = this.getConstraintDate(relation, getEndDate, task);\r\n\r\n\r\n\t\t\tif(this.isSmallerOrDefault(defaultStart, constraintDate, task) && this.isSmallerOrDefault(minStart, constraintDate, task)){\r\n\t\t\t\tminStart = constraintDate;\r\n\t\t\t\tlinkId = relation.id;\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif(minStart){\r\n\t\t\tminStart = gantt.getClosestWorkTime({date:minStart, dir:\"future\", task:gantt.getTask(taskId)});\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tlink: linkId,\r\n\t\t\ttask: taskId,\r\n\t\t\tstart_date: minStart\r\n\t\t};\r\n\t},\r\n\tgetConstraintDate: function(relation, getEndDate, task){\r\n\t\tvar predecessorEnd = getEndDate(relation.source);\r\n\t\tvar successor = task;\r\n\r\n\t\tvar successorStart = gantt.getClosestWorkTime({date:predecessorEnd, dir:\"future\", task:successor});\r\n\r\n\t\tif(predecessorEnd && relation.lag && relation.lag*1 == relation.lag){\r\n\t\t\tsuccessorStart = gantt.calculateEndDate({start_date: predecessorEnd, duration: relation.lag*1, task: successor});\r\n\t\t}\r\n\r\n\t\treturn successorStart;\r\n\t}\r\n};\r\n\r\ngantt._autoSchedulingPlanner = {\r\n\tgeneratePlan: function(relations){\r\n\r\n\t\tvar graph = gantt._autoSchedulingGraph;\r\n\t\tvar orderedIds = graph.topologicalSort(relations);\r\n\t\tvar predecessorRelations = {},\r\n\t\t\tplansHash = {};\r\n\r\n\t\tvar id;\r\n\t\tfor(var i = 0, len = orderedIds.length; i < len; i++){\r\n\t\t\tid = orderedIds[i];\r\n\t\t\tvar task = gantt.getTask(id);\r\n\t\t\tif(task.auto_scheduling === false){\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tpredecessorRelations[id] = [];\r\n\t\t\tplansHash[id] = null;\r\n\t\t}\r\n\r\n\t\tfunction getPredecessorEndDate(id){\r\n\t\t\tvar plan = plansHash[id];\r\n\t\t\tvar task = gantt.getTask(id);\r\n\t\t\tvar res;\r\n\r\n\t\t\tif(!(plan && (plan.start_date || plan.end_date))){\r\n\t\t\t\tres = task.end_date;\r\n\t\t\t}else if(plan.end_date){\r\n\t\t\t\tres = plan.end_date;\r\n\t\t\t}else {\r\n\t\t\t\tres = gantt.calculateEndDate({start_date: plan.start_date, duration: task.duration, task: task});\r\n\t\t\t}\r\n\r\n\t\t\treturn res;\r\n\t\t}\r\n\r\n\t\tvar rel;\r\n\t\tfor(var i = 0, len = relations.length; i < len; i++){\r\n\t\t\trel = relations[i];\r\n\t\t\tif(predecessorRelations[rel.target]) {\r\n\t\t\t\tpredecessorRelations[rel.target].push(rel);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar dateResolver = gantt._autoSchedulingDateResolver;\r\n\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < orderedIds.length; i++){\r\n\t\t\tvar currentId = orderedIds[i];\r\n\r\n\t\t\tvar plan = dateResolver.resolveRelationDate(currentId, predecessorRelations[currentId] || [], getPredecessorEndDate);\r\n\r\n\r\n\t\t\tif(plan.start_date && gantt.isLinkExists(plan.link)){\r\n\t\t\t\tvar link = gantt.getLink(plan.link);\r\n\t\t\t\tvar task = gantt.getTask(currentId);\r\n\t\t\t\tvar predecessor = gantt.getTask(link.source);\r\n\r\n\t\t\t\tif (task.start_date.valueOf() !== plan.start_date.valueOf() && gantt.callEvent(\"onBeforeTaskAutoSchedule\", [task, plan.start_date, link, predecessor]) === false) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tplansHash[currentId] = plan;\r\n\t\t\tif(plan.start_date){\r\n\t\t\t\tresult.push(plan);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t},\r\n\r\n\tapplyProjectPlan: function(projectPlan){\r\n\t\tvar plan, task, link, predecessor;\r\n\r\n\t\tvar updateTasks = [];\r\n\t\tfor(var i = 0; i <  projectPlan.length; i++){\r\n\t\t\tlink = null;\r\n\t\t\tpredecessor = null;\r\n\t\t\tplan = projectPlan[i];\r\n\r\n\t\t\tif(!plan.task) continue;\r\n\r\n\t\t\ttask = gantt.getTask(plan.task);\r\n\t\t\tif(plan.link){\r\n\t\t\t\tlink = gantt.getLink(plan.link);\r\n\t\t\t\tpredecessor = gantt.getTask(link.source);\r\n\t\t\t}\r\n\r\n\t\t\tvar newDate = null;\r\n\t\t\tif(plan.start_date && (task.start_date.valueOf() != plan.start_date.valueOf())){\r\n\t\t\t\tnewDate = plan.start_date;\r\n\t\t\t}\r\n\r\n\t\t\tif(!newDate) continue;\r\n\t\t\t\r\n\t\t\ttask.start_date = newDate;\r\n\t\t\ttask.end_date = gantt.calculateEndDate(task);\r\n\r\n\t\t\tupdateTasks.push(task.id);\r\n\t\t\tgantt.callEvent(\"onAfterTaskAutoSchedule\", [task, newDate, link, predecessor]);\r\n\r\n\t\t}\r\n\t\treturn updateTasks;\r\n\t}\r\n};\r\n\r\ngantt._autoSchedulingPreferredDates = function(startTask, relations){\r\n\tfor(var i = 0; i < relations.length; i++){\r\n\t\tvar rel = relations[i];\r\n\t\tvar task = gantt.getTask(rel.target);\r\n\r\n\t\tif(!gantt.config.auto_scheduling_strict || rel.target == startTask){\r\n\t\t\trel.preferredStart = new Date(task.start_date);\r\n\t\t}\r\n\t}\r\n};\r\n\r\ngantt._autoSchedule = function(id, relations, updateCallback){\r\n\tif (gantt.callEvent(\"onBeforeAutoSchedule\", [id]) === false) {\r\n\t\treturn;\r\n\t}\r\n\tgantt._autoscheduling_in_progress = true;\r\n\r\n\tvar path = gantt._autoSchedulingPath;\r\n\r\n\tvar updatedTasks = [];\r\n\r\n\tvar cycles = path.findLoops(relations);\r\n\tif(cycles.length){\r\n\t\tgantt.callEvent(\"onAutoScheduleCircularLink\", [cycles]);\r\n\t}else{\r\n\r\n\t\tvar planner = gantt._autoSchedulingPlanner;\r\n\t\tgantt._autoSchedulingPreferredDates(id, relations);\r\n\r\n\t\tvar plan = planner.generatePlan(relations);\r\n\t\tupdatedTasks = planner.applyProjectPlan(plan);\r\n\r\n\t\tif(updateCallback){\r\n\t\t\tupdateCallback(updatedTasks);\r\n\t\t}\r\n\t}\r\n\r\n\tgantt._autoscheduling_in_progress = false;\r\n\tgantt.callEvent(\"onAfterAutoSchedule\", [id, updatedTasks]);\r\n\r\n\treturn updatedTasks;\r\n};\r\n\r\ngantt.autoSchedule = function(id, inclusive){\r\n\r\n\tif(inclusive === undefined){\r\n\t\tinclusive = true;\r\n\t}else{\r\n\t\tinclusive = !!inclusive;\r\n\t}\r\n\r\n\tvar relations =  gantt._autoSchedulingPath.getLinkedTasks(id, inclusive);\r\n\r\n\tvar totalRelations = relations.length;\r\n\tvar startAutoSchedule = Date.now();\r\n\tgantt._autoSchedule(id, relations, gantt._finalizeAutoSchedulingChanges);\r\n\tvar durationAutoSchedule = Date.now() - startAutoSchedule;\r\n};\r\n\r\ngantt._finalizeAutoSchedulingChanges = function(updatedTasks){\r\n\tfunction resetTime(task){\r\n\t\tif(batchUpdate)\r\n\t\t\treturn;\r\n\r\n\t\tvar start = task.start_date.valueOf(),\r\n\t\t\tend = task.end_date.valueOf();\r\n\r\n\t\tgantt.resetProjectDates(task);\r\n\t\tif(task.start_date.valueOf() != start || task.end_date.valueOf() != end){\r\n\t\t\tbatchUpdate = true;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tvar children = gantt.getChildren(task.id);\r\n\t\tfor(var i = 0; !batchUpdate && i < children.length; i++){\r\n\t\t\tresetTime(gantt.getTask(children[i]));\r\n\t\t}\r\n\t}\r\n\r\n\tvar batchUpdate = false;\r\n\t// call batchUpdate (full repaint) only if we update multiple tasks,\r\n\tif(updatedTasks.length == 1){\r\n\t\tgantt.eachParent(resetTime, updatedTasks[0]);\r\n\t}else if(updatedTasks.length){\r\n\t\tbatchUpdate = true;\r\n\t}\r\n\r\n\tfunction payload(){\r\n\t\tfor(var i = 0; i < updatedTasks.length; i++){\r\n\t\t\tgantt.updateTask(updatedTasks[i]);\r\n\t\t}\r\n\t}\r\n\tif(batchUpdate){\r\n\t\tgantt.batchUpdate(payload);\r\n\t}else{\r\n\t\tpayload();\r\n\t}\r\n\r\n};\r\n\r\ngantt.isCircularLink = function(link){\r\n\treturn !!gantt._getConnectedGroup(link);\r\n\r\n};\r\n\r\ngantt._getConnectedGroup = function(link){\r\n\tvar manager = gantt._autoSchedulingPath;\r\n\r\n\tvar allRelations = manager.getLinkedTasks();\r\n\tif(!gantt.isLinkExists(link.id)){\r\n\t\tallRelations = allRelations.concat(gantt._formatLink(link));\r\n\t}\r\n\r\n\tvar cycles = manager.findLoops(allRelations);\r\n\r\n\tvar found = false;\r\n\tfor(var i = 0; (i < cycles.length) && !found; i++){\r\n\t\tvar links = cycles[i].links;\r\n\t\tfor(var j = 0; j < links.length; j++){\r\n\t\t\tif(links[j] == link.id){\r\n\t\t\t\treturn cycles[i];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn null;\r\n};\r\n\r\ngantt.findCycles = function(){\r\n\tvar manager = gantt._autoSchedulingPath;\r\n\r\n\tvar allRelations = manager.getLinkedTasks();\r\n\treturn manager.findLoops(allRelations);\r\n};\r\n\r\ngantt._attachAutoSchedulingHandlers = function(){\r\n\r\n\tgantt._autoScheduleAfterLinkChange = function (linkId, link) {\r\n\t\tif (gantt.config.auto_scheduling && !this._autoscheduling_in_progress) {\r\n\t\t\tgantt.autoSchedule(link.source);\r\n\t\t}\r\n\t};\r\n\r\n\tgantt.attachEvent(\"onAfterLinkUpdate\", gantt._autoScheduleAfterLinkChange);\r\n\tgantt.attachEvent(\"onAfterLinkAdd\", gantt._autoScheduleAfterLinkChange);\r\n\r\n\tgantt.attachEvent(\"onAfterLinkDelete\", function(id, link){\r\n\t\tif (this.config.auto_scheduling && !this._autoscheduling_in_progress && this.isTaskExists(link.target)) {\r\n\t\t\t// after link deleted - auto schedule target for other relations that may be left\r\n\t\t\tvar target = this.getTask(link.target);\r\n\t\t\tvar predecessors = this._getPredecessors(target);\r\n\t\t\tif(predecessors.length){\r\n\t\t\t\tthis.autoSchedule(predecessors[0].source, false);\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\r\n\tgantt.attachEvent(\"onParse\", function(){\r\n\t\tif (gantt.config.auto_scheduling && gantt.config.auto_scheduling_initial) {\r\n\t\t\tgantt.autoSchedule();\r\n\t\t}\r\n\t});\r\n\r\n\tgantt._preventCircularLink = function(id, link){\r\n\t\tif(gantt.isCircularLink(link)){\r\n\t\t\tgantt.callEvent(\"onCircularLinkError\", [link, gantt._getConnectedGroup(link)]);\r\n\t\t\treturn false;\r\n\t\t}else{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t};\r\n\r\n\tgantt._preventDescendantLink = function(id, link){\r\n\t\tvar source = gantt.getTask(link.source),\r\n\t\t\ttarget = gantt.getTask(link.target);\r\n\r\n\t\tif(!gantt.config.auto_scheduling_descendant_links){\r\n\t\t\tif((gantt.isChildOf(source.id, target.id) && gantt.isSummaryTask(target)) || (gantt.isChildOf(target.id, source.id) && gantt.isSummaryTask(source))){\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t};\r\n\r\n\tgantt.attachEvent(\"onBeforeLinkAdd\", gantt._preventCircularLink);\r\n\tgantt.attachEvent(\"onBeforeLinkAdd\", gantt._preventDescendantLink);\r\n\tgantt.attachEvent(\"onBeforeLinkUpdate\", gantt._preventCircularLink);\r\n\tgantt.attachEvent(\"onBeforeLinkUpdate\", gantt._preventDescendantLink);\r\n\r\n\tgantt._datesNotEqual = function(dateA, dateB, taskA, taskB){\r\n\t\tif(dateA.valueOf() > dateB.valueOf()){\r\n\t\t\treturn this._hasDuration({start_date: dateB, end_date: dateA, task: taskB});\r\n\t\t}else{\r\n\t\t\treturn this._hasDuration({start_date: dateA, end_date: dateB, task: taskA});\r\n\t\t}\r\n\t};\r\n\tgantt._notEqualTaskDates = function(task1, task2){\r\n\t\tif (this._datesNotEqual(task1.start_date, task2.start_date, task1, task2) ||\r\n\t\t\t((this._datesNotEqual(task1.end_date, task2.end_date, task1, task2) ||\r\n\t\t\t\ttask1.duration != task2.duration) && task1.type != gantt.config.types.milestone)) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t};\r\n\r\n\tvar relations;\r\n\tvar movedTask;\r\n\tgantt.attachEvent(\"onBeforeTaskDrag\", function(id, mode, task){\r\n\t\tif(gantt.config.auto_scheduling && gantt.config.auto_scheduling_move_projects){\r\n\t\t\t// collect relations before drag and drop  in order to have original positions of subtasks within project since they are used as lag when moving dependent project\r\n\t\t\trelations = gantt._autoSchedulingPath.getLinkedTasks(id, true);\r\n\t\t\tmovedTask = id;\r\n\t\t}\r\n\t\treturn true;\r\n\t});\r\n\r\n\tfunction resetToStartLinksLags(taskId, relations){\r\n\t\tvar skipped = false;\r\n\t\tfor(var i = 0; i < relations.length; i++){\r\n\t\t\tvar originalLink = gantt.getLink(relations[i].id);\r\n\t\t\tif(originalLink.type == gantt.config.links.start_to_start || originalLink.type == gantt.config.links.start_to_finish){\r\n\t\t\t\trelations.splice(i, 1);\r\n\t\t\t\ti--;\r\n\t\t\t\tskipped = true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif(skipped){\r\n\t\t\tvar presentLinks = {};\r\n\t\t\tfor(var i = 0; i < relations.length; i++){\r\n\t\t\t\tpresentLinks[relations[i].id] = true;\r\n\t\t\t}\r\n\r\n\t\t\tvar updatedLinks = gantt._autoSchedulingPath.getLinkedTasks(taskId, true);\r\n\t\t\tfor(var i = 0; i < updatedLinks.length; i++){\r\n\t\t\t\tif(!presentLinks[updatedLinks[i].id]){\r\n\t\t\t\t\trelations.push(updatedLinks[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tgantt._autoScheduleAfterDND = function(taskId, task){\r\n\t\tif (gantt.config.auto_scheduling && !this._autoscheduling_in_progress) {\r\n\t\t\tvar newTask = this.getTask(taskId);\r\n\t\t\tif (gantt._notEqualTaskDates(task, newTask)){\r\n\t\t\t\tif(gantt.config.auto_scheduling_move_projects && movedTask == taskId){\r\n\r\n\t\t\t\t\tif(gantt.calculateDuration(task) != gantt.calculateDuration(newTask)){\r\n\t\t\t\t\t\t// task duration is used as lag when converting start_to_start and start_to_finish into finish to start links\r\n\t\t\t\t\t\t// recalculate these links if task duration has changed\r\n\t\t\t\t\t\tresetToStartLinksLags(taskId, relations);\r\n\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t\tgantt._autoSchedule(taskId, relations, gantt._finalizeAutoSchedulingChanges);\r\n\t\t\t\t}else{\r\n\t\t\t\t\tgantt.autoSchedule(newTask.id);\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t}\r\n\t\t}\r\n\t\trelations = null;\r\n\t\tmovedTask = null;\r\n\t\treturn true;\r\n\t};\r\n\r\n\tgantt._lightBoxChangesHandler = function (taskId, task) {\r\n\t\tif (gantt.config.auto_scheduling && !this._autoscheduling_in_progress) {\r\n\t\t\tvar oldTask = this.getTask(taskId);\r\n\t\t\tif (gantt._notEqualTaskDates(task, oldTask)) {\r\n\t\t\t\tgantt._autoschedule_lightbox_id = taskId;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t};\r\n\tgantt._lightBoxSaveHandler = function (taskId, task) {\r\n\r\n\t\tif (gantt.config.auto_scheduling && !this._autoscheduling_in_progress) {\r\n\t\t\tif (gantt._autoschedule_lightbox_id && gantt._autoschedule_lightbox_id == taskId) {\r\n\t\t\t\tgantt._autoschedule_lightbox_id = null;\r\n\t\t\t\tgantt.autoSchedule(task.id);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t};\r\n\r\n\r\n\r\n\r\n\tgantt.attachEvent(\"onBeforeTaskChanged\", function(id, mode, task){ return gantt._autoScheduleAfterDND(id, task); });\r\n\tgantt.attachEvent(\"onLightboxSave\", gantt._lightBoxChangesHandler);\r\n\tgantt.attachEvent(\"onAfterTaskUpdate\", gantt._lightBoxSaveHandler);\r\n\r\n\r\n};\r\n\r\n\r\ngantt.attachEvent(\"onGanttReady\", function(){\r\n\tgantt._attachAutoSchedulingHandlers();\r\n\t// attach handlers only when initialized for the first time\r\n\tgantt._attachAutoSchedulingHandlers = function(){};\r\n});\r\n\r\n})();\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\nvar units = {\r\n\t\"second\": 1,\r\n\t\"minute\": 60,\r\n\t\"hour\": 60 * 60,\r\n\t\"day\": 60 * 60 * 24,\r\n\t\"week\": 60 * 60 * 24 * 7,\r\n\t\"month\": 60 * 60 * 24 * 30,\r\n\t\"quarter\": 60 * 60 * 24 * 30 * 3,\r\n\t\"year\": 60 * 60 * 24 * 365\r\n};\r\nfunction getSecondsInUnit(unit){\r\n\treturn units[unit] || units.hour;\r\n}\r\n\r\nfunction forEach(arr, callback){\r\n\tif(arr.forEach){\r\n\t\tarr.forEach(callback);\r\n\t}else{\r\n\t\tvar workArray = arr.slice();\r\n\t\tfor(var i = 0; i < workArray.length; i++){\r\n\t\t\tcallback(workArray[i], i);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction arrayMap(arr, callback){\r\n\tif(arr.map){\r\n\t\treturn arr.map(callback);\r\n\t}else{\r\n\t\tvar workArray = arr.slice();\r\n\t\tvar resArray = [];\r\n\r\n\t\tfor(var i = 0; i < workArray.length; i++){\r\n\t\t\tresArray.push(callback(workArray[i], i));\r\n\t\t}\r\n\r\n\t\treturn resArray;\r\n\t}\r\n\r\n}\r\n\r\nmodule.exports = {\r\n\tgetSecondsInUnit: getSecondsInUnit,\r\n\tforEach: forEach,\r\n\tarrayMap: arrayMap\r\n};\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// dhtmlxgantt_auto_scheduling.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 9278c35520642ffbe1b9","module.exports = function(gantt) {\r\n// helpers for building chain of dependencies, used for critical path calculation and for auto scheduling\r\n\r\n\tgantt._get_linked_task = function (link, getTarget) {\r\n\t\tvar task = null;\r\n\t\tvar taskId = getTarget ? link.target : link.source;\r\n\r\n\t\tif (gantt.isTaskExists(taskId)) {\r\n\t\t\ttask = gantt.getTask(taskId);\r\n\t\t}\r\n\r\n\t\treturn task;\r\n\t};\r\n\tgantt._get_link_target = function (link) {\r\n\t\treturn gantt._get_linked_task(link, true);\r\n\t};\r\n\r\n\tgantt._get_link_source = function (link) {\r\n\t\treturn gantt._get_linked_task(link, false);\r\n\t};\r\n\r\n\tvar caching = false;\r\n\tvar formattedLinksStash = {};\r\n\tvar inheritedSuccessorsStash = {};\r\n\tvar inheritedPredecessorsStash = {};\r\n\tvar getPredecessorsCache = {};\r\n\r\n\r\n\tgantt._isLinksCacheEnabled = function(){\r\n\t\treturn caching;\r\n\t};\r\n\tgantt._startLinksCache = function(){\r\n\t\tformattedLinksStash = {};\r\n\t\tinheritedSuccessorsStash = {};\r\n\t\tinheritedPredecessorsStash = {};\r\n\t\tgetPredecessorsCache = {};\r\n\t\tcaching = true;\r\n\t};\r\n\tgantt._endLinksCache = function(){\r\n\t\tformattedLinksStash = {};\r\n\t\tinheritedSuccessorsStash = {};\r\n\t\tinheritedPredecessorsStash = {};\r\n\t\tgetPredecessorsCache = {};\r\n\t\tcaching = false;\r\n\t};\r\n\r\n\tgantt._formatLink = function (link) {\r\n\r\n\r\n\t\tif(caching && formattedLinksStash[link.id]){\r\n\t\t\treturn formattedLinksStash[link.id];\r\n\t\t}\r\n\r\n\t\tvar relations = [];\r\n\t\tvar target = this._get_link_target(link);\r\n\t\tvar source = this._get_link_source(link);\r\n\r\n\t\tif (!(source && target)) {\r\n\t\t\treturn relations;\r\n\t\t}\r\n\r\n\t\tif ((gantt.isSummaryTask(target) && gantt.isChildOf(source.id, target.id)) || (gantt.isSummaryTask(source) && gantt.isChildOf(target.id, source.id))) {\r\n\t\t\treturn relations;\r\n\t\t}\r\n\r\n\r\n\t\t// there are three kinds of connections at this point\r\n\t\t// task -> task - regular link\r\n\t\t// task -> project - transform it into set of regular links (task -> [each subtask]), use offset beetween subtask and project dates as lag, in order not to change mutual positions of subtasks inside a project\r\n\t\t// project -> task - transform it into ([each subtask] -> task) links\r\n\t\t// project -> project - transform it into ([each subtask of p1] -> [each subtask of p2]) links\r\n\r\n\t\tvar from = this._getImplicitLinks(link, source, function (c) {\r\n\t\t\treturn 0;\r\n\t\t}, true);\r\n\r\n\t\tvar respectTargetOffset = gantt.config.auto_scheduling_move_projects;\r\n\t\tvar targetDates = this.isSummaryTask(target) ? this.getSubtaskDates(target.id) : {\r\n\t\t\tstart_date: target.start_date,\r\n\t\t\tend_date: target.end_date\r\n\t\t};\r\n\t\tvar to = this._getImplicitLinks(link, target, function (c) {\r\n\t\t\tif (!respectTargetOffset) {\r\n\t\t\t\treturn 0;\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif (!c.$target.length && !(gantt.getState().drag_id == c.id)) {// drag_id - virtual lag shouldn't restrict task that is being moved inside project\r\n\t\t\t\t\treturn gantt.calculateDuration({\r\n\t\t\t\t\t\tstart_date: targetDates.start_date,\r\n\t\t\t\t\t\tend_date: c.start_date,\r\n\t\t\t\t\t\ttask: source\r\n\t\t\t\t\t});\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn 0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tfor (var i = 0, fromLength = from.length; i < fromLength; i++) {\r\n\t\t\tvar fromTask = from[i];\r\n\t\t\tfor (var j = 0, toLength = to.length; j < toLength; j++) {\r\n\t\t\t\tvar toTask = to[j];\r\n\r\n\t\t\t\tvar lag = fromTask.lag * 1 + toTask.lag * 1;\r\n\r\n\t\t\t\tvar subtaskLink = {\r\n\t\t\t\t\tid: link.id,\r\n\t\t\t\t\ttype: link.type,\r\n\t\t\t\t\tsource: fromTask.task,\r\n\t\t\t\t\ttarget: toTask.task,\r\n\t\t\t\t\tlag: (link.lag * 1 || 0) + lag\r\n\t\t\t\t};\r\n\r\n\t\t\t\trelations.push(gantt._convertToFinishToStartLink(toTask.task, subtaskLink, source, target, fromTask.taskParent, toTask.taskParent));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif(caching)\r\n\t\t\tformattedLinksStash[link.id] = relations;\r\n\r\n\t\treturn relations;\r\n\t};\r\n\r\ngantt._isAutoSchedulable = function(task){\r\n\treturn task.auto_scheduling !== false;\r\n};\r\n\r\ngantt._getImplicitLinks = function(link, parent, selectOffset, selectSourceLinks){\r\n\tvar relations = [];\r\n\r\n\tif(this.isSummaryTask(parent)){\r\n\r\n\t\t// if the summary task contains multiple chains of linked tasks - no need to consider every task of the chain,\r\n\t\t// it will be enough to check the first/last tasks of the chain\r\n\t\t// special conditions if there are unscheduled tasks in the chain, or negative lag values\r\n\t\tvar children = {};\r\n\t\tthis.eachTask(function(c){\r\n\t\t\tif(!this.isSummaryTask(c)){\r\n\t\t\t\tchildren[c.id] = c;\r\n\t\t\t}\r\n\t\t}, parent.id);\r\n\r\n\t\tvar skipChild;\r\n\r\n\t\tfor(var c in children){\r\n\t\t\tvar task = children[c];\r\n\t\t\tvar linksCollection = selectSourceLinks ? task.$source : task.$target;\r\n\r\n\t\t\tskipChild = false;\r\n\r\n\t\t\tfor(var l = 0; l < linksCollection.length; l++){\r\n\t\t\t\tvar siblingLink = gantt.getLink(linksCollection[l]);\r\n\t\t\t\tvar siblingId = selectSourceLinks ? siblingLink.target : siblingLink.source;\r\n\r\n\t\t\t\tif(children[siblingId] && task.auto_scheduling !== false && children[siblingId].auto_scheduling !== false && siblingLink.lag >= 0){\r\n\t\t\t\t\tskipChild = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(!skipChild){\r\n\t\t\t\trelations.push({task: task.id, taskParent: task.parent, lag: selectOffset(task)});\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}else{\r\n\t\trelations.push({task:parent.id, taskParent: parent.parent, lag: 0});\r\n\t}\r\n\r\n\t\treturn relations;\r\n};\r\n\r\n\tgantt._getDirectDependencies = function (task, selectSuccessors) {\r\n\r\n\t\tvar links = [],\r\n\t\t\tsuccessors = [];\r\n\r\n\t\tvar linksIds = selectSuccessors ? task.$source : task.$target;\r\n\r\n\tfor(var i = 0; i < linksIds.length; i++){\r\n\t\tvar link = this.getLink(linksIds[i]);\r\n\t\tif(this.isTaskExists(link.source) && this.isTaskExists(link.target)) {\r\n\t\t\tvar target = this.getTask(link.target);\r\n\t\t\tif(this._isAutoSchedulable(target)){\r\n\t\t\t\tlinks.push(this.getLink(linksIds[i]));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t\tfor (var i = 0; i < links.length; i++) {\r\n\t\t\tsuccessors = successors.concat(this._formatLink(links[i]));\r\n\t\t}\r\n\r\n\t\treturn successors;\r\n\t};\r\n\r\n\tgantt._getInheritedDependencies = function (task, selectSuccessors) {\r\n\r\n\t\t//var successors = [];\r\n\tvar stop = false;\r\n\tvar inheritedRelations = [];\r\n\tvar cacheCollection;\r\n\tif(this.isTaskExists(task.id)){\r\n\r\n\t\tvar parent = this.getParent(task.id);\r\n\r\n\r\n\t\tthis.eachParent(function(parent){\r\n\t\t\tif(stop)\r\n\t\t\t\treturn;\r\n\r\n\t\t\tif(caching){\r\n\t\t\t\tcacheCollection = selectSuccessors ? inheritedSuccessorsStash : inheritedPredecessorsStash;\r\n\t\t\t\tif(cacheCollection[parent.id]){\r\n\t\t\t\t\tinheritedRelations.push.apply(inheritedRelations, cacheCollection[parent.id]);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tvar parentDependencies;\r\n\t\t\tif(this.isSummaryTask(parent)){\r\n\t\t\t\tif(!this._isAutoSchedulable(parent)){\r\n\t\t\t\t\tstop = true;\r\n\t\t\t\t}else{\r\n\t\t\t\t\tparentDependencies = this._getDirectDependencies(parent, selectSuccessors);\r\n\t\t\t\t\tif(caching){\r\n\t\t\t\t\t\tcacheCollection[parent.id] = parentDependencies;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tinheritedRelations.push.apply(inheritedRelations, parentDependencies);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t}, task.id, this);\r\n\r\n\t\t//\tfor (var i = 0; i < inheritedRelations.length; i++) {\r\n\t\t//\t\tsuccessors.push(inheritedRelations[i]);\r\n\t\t//\t}\r\n\t\t}\r\n\r\n\t\treturn inheritedRelations;\r\n\t};\r\n\r\n\r\n\tgantt._getDirectSuccessors = function (task) {\r\n\t\treturn this._getDirectDependencies(task, true);\r\n\t};\r\n\r\n\tgantt._getInheritedSuccessors = function (task) {\r\n\t\treturn this._getInheritedDependencies(task, true);\r\n\t};\r\n\r\n\tgantt._getDirectPredecessors = function (task) {\r\n\t\treturn this._getDirectDependencies(task, false);\r\n\t};\r\n\r\n\tgantt._getInheritedPredecessors = function (task) {\r\n\t\treturn this._getInheritedDependencies(task, false);\r\n\t};\r\n\r\n\tgantt._getSuccessors = function (task, skipInherited) {\r\n\t\tvar successors = this._getDirectSuccessors(task);\r\n\t\tif(skipInherited){\r\n\t\t\treturn successors;\r\n\t\t}else{\r\n\t\t\treturn successors.concat(this._getInheritedSuccessors(task));\r\n\t\t}\r\n\t};\r\n\r\n\tgantt._getPredecessors = function (task, skipInherited) {\r\n\t\tvar key = task.id + skipInherited;\r\n\t\tvar result;\r\n\r\n\t\tif(caching && getPredecessorsCache[key]){\r\n\t\t\treturn getPredecessorsCache[key];\r\n\t\t}\r\n\r\n\t\tvar predecessors = this._getDirectPredecessors(task);\r\n\t\tif(skipInherited){\r\n\t\t\tresult = predecessors;\r\n\t\t}else{\r\n\t\t\tresult = predecessors.concat(this._getInheritedPredecessors(task));\r\n\t\t}\r\n\t\tif(caching){\r\n\t\t\tgetPredecessorsCache[key] = result;\r\n\t\t}\r\n\t\treturn result;\r\n\t};\r\n\r\n\r\n\tgantt._convertToFinishToStartLink = function (id, link, sourceTask, targetTask, sourceParent, targetParent) {\r\n\t\t// convert finish-to-finish, start-to-finish and start-to-start to finish-to-start link and provide some additional properties\r\n\t\tvar res = {\r\n\t\t\ttarget: id,\r\n\t\t\tlink: gantt.config.links.finish_to_start,\r\n\t\t\tid: link.id,\r\n\t\t\tlag: link.lag || 0,\r\n\t\t\tsource: link.source,\r\n\t\t\tpreferredStart: null,\r\n\t\t\tsourceParent: sourceParent,\r\n\t\t\ttargetParent: targetParent\r\n\t\t};\r\n\r\n\t\tvar additionalLag = 0;\r\n\t\tswitch (link.type) {\r\n\t\t\tcase gantt.config.links.start_to_start:\r\n\t\t\t\tadditionalLag = -sourceTask.duration;\r\n\t\t\t\tbreak;\r\n\t\t\tcase gantt.config.links.finish_to_finish:\r\n\t\t\t\tadditionalLag = -targetTask.duration;\r\n\t\t\t\tbreak;\r\n\t\t\tcase gantt.config.links.start_to_finish:\r\n\t\t\t\tadditionalLag = -sourceTask.duration - targetTask.duration;\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tadditionalLag = 0;\r\n\t\t}\r\n\r\n\t\tres.lag += additionalLag;\r\n\t\treturn res;\r\n\t};\r\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/core/links_common.js\n// module id = 1\n// module chunks = 1 3","require(\"../core/links_common\")(gantt);\r\n\r\ngantt.config.auto_scheduling = false;\r\ngantt.config.auto_scheduling_descendant_links = false;\r\ngantt.config.auto_scheduling_initial = true;\r\ngantt.config.auto_scheduling_strict = false;\r\ngantt.config.auto_scheduling_move_projects = true;\r\n\r\n(function(){\r\n\r\nvar helpers = require(\"../utils/helpers\");\r\n\r\n\r\ngantt._autoSchedulingGraph = {\r\n\tgetVertices: function(relations){\r\n\t\tvar ids = {};\r\n\t\tvar rel;\r\n\t\tfor(var i = 0, len = relations.length; i < len; i++){\r\n\t\t\trel = relations[i];\r\n\t\t\tids[rel.target] = rel.target;\r\n\t\t\tids[rel.source] = rel.source;\r\n\t\t}\r\n\r\n\t\tvar vertices = [];\r\n\t\tvar id;\r\n\t\tfor(var i in ids){\r\n\t\t\tid = ids[i];\r\n\t\t\tvertices.push(id);\r\n\t\t}\r\n\r\n\t\treturn vertices;\r\n\t},\r\n\ttopologicalSort: function(edges){\r\n\t\tvar vertices = this.getVertices(edges);\r\n\t\tvar hash = {};\r\n\r\n\t\tfor(var i = 0, len = vertices.length; i < len; i ++){\r\n\t\t\thash[vertices[i]] = {id: vertices[i], $source:[], $target:[], $incoming: 0};\r\n\t\t}\r\n\r\n\t\tfor(var i = 0, len = edges.length; i < len; i++){\r\n\t\t\tvar successor = hash[edges[i].target];\r\n\t\t\tsuccessor.$target.push(i);\r\n\t\t\tsuccessor.$incoming = successor.$target.length;\r\n\t\t\thash[edges[i].source].$source.push(i);\r\n\r\n\t\t}\r\n\r\n\t\t// topological sort, Kahn's algorithm\r\n\t\tvar S = vertices.filter(function(v){ return !hash[v].$incoming; });\r\n\r\n\t\tvar L = [];\r\n\r\n\t\twhile(S.length){\r\n\t\t\tvar n = S.pop();\r\n\r\n\t\t\tL.push(n);\r\n\r\n\t\t\tvar node = hash[n];\r\n\r\n\t\t\tfor(var i = 0; i < node.$source.length; i++){\r\n\t\t\t\tvar m = hash[edges[node.$source[i]].target];\r\n\t\t\t\tm.$incoming--;\r\n\t\t\t\tif(!m.$incoming){\r\n\t\t\t\t\tS.push(m.id);\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn L;\r\n\r\n\t},\r\n\t_groupEdgesBySource: function(edges){\r\n\t\tvar res = {};\r\n\t\tvar edge;\r\n\t\tfor(var i = 0, len = edges.length; i < len; i++){\r\n\t\t\tedge = edges[i];\r\n\t\t\tif(!res[edge.source]){\r\n\t\t\t\tres[edge.source] = [];\r\n\t\t\t}\r\n\t\t\tres[edge.source].push(edge);\r\n\t\t}\r\n\t\treturn res;\r\n\t},\r\n\ttarjanStronglyConnectedComponents: function(vertices, edges){\r\n\t\t//https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\r\n\t\tvar verticesHash = {};\r\n\r\n\t\tvar index = 0;\r\n\t\tvar S = [];\r\n\t\tvar connectedEdges = [];\r\n\t\tvar connectedComponents = [];\r\n\r\n\t\tvar edgesFromTasks = this._groupEdgesBySource(edges);\r\n\r\n\t\tvar vertexId;\r\n\t\tfor(var v = 0, len = vertices.length; v < len; v++){\r\n\t\t\tvertexId = vertices[v];\r\n\t\t\tvar vertex = getVertex(vertexId);\r\n\t\t\tif(vertex.index === undefined){\r\n\t\t\t\tstrongConnect(vertexId);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction strongConnect(vertexId, previousLink){\r\n\t\t\tvar v = getVertex(vertexId);\r\n\t\t\tv.index = index;\r\n\t\t\tv.lowLink = index;\r\n\t\t\tindex++;\r\n\r\n\t\t\tif(previousLink){\r\n\t\t\t\tconnectedEdges.push(previousLink);\r\n\t\t\t}\r\n\r\n\t\t\tS.push(v);\r\n\t\t\tv.onStack = true;\r\n\r\n\t\t\t// Consider successors of v\r\n\r\n\t\t\tvar edge;\r\n\t\t\tvar successors = edgesFromTasks[vertexId];\r\n\t\t\tfor(var e = 0; successors  && e < successors.length; e++){\r\n\t\t\t\tedge = successors[e];\r\n\t\t\t\tif(edge.source != vertexId) continue;\r\n\r\n\t\t\t\tvar v = getVertex(edge.source);\r\n\t\t\t\tvar w = getVertex(edge.target);\r\n\t\t\t\tif(w.index === undefined){\r\n\t\t\t\t\t// Successor w has not yet been visited; recurse on it\r\n\t\t\t\t\tstrongConnect(edge.target, edge);\r\n\t\t\t\t\tv.lowLink = Math.min(v.lowLink, w.lowLink);\r\n\t\t\t\t}else if(w.onStack){\r\n\t\t\t\t\t// Successor w is in stack S and hence in the current SCC\r\n\t\t\t\t\tv.lowLink = Math.min(v.lowLink, w.index);\r\n\t\t\t\t\tconnectedEdges.push(edge);\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// If v is a root node, pop the stack and generate an SCC\r\n\t\t\tif(v.lowLink == v.index){\r\n\t\t\t\tvar connectedComponent = {tasks: [], links:[]};\r\n\t\t\t\tvar w;\r\n\t\t\t\tdo{\r\n\t\t\t\t\tvar rel = connectedEdges.pop();\r\n\t\t\t\t\tw = S.pop();\r\n\t\t\t\t\tw.onStack = false;\r\n\t\t\t\t\tconnectedComponent.tasks.push(w.id);\r\n\t\t\t\t\tif(rel){\r\n\t\t\t\t\t\tconnectedComponent.links.push(rel.id);\r\n\t\t\t\t\t}\r\n\t\t\t\t}while(w.id != v.id);\r\n\t\t\t\tconnectedComponents.push(connectedComponent);\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn connectedComponents;\r\n\r\n\t\tfunction getVertex(id){\r\n\t\t\tif(!verticesHash[id]){\r\n\t\t\t\tverticesHash[id] = {id: id, onStack:false, index: undefined, lowLink: undefined};\r\n\t\t\t}\r\n\r\n\t\t\treturn verticesHash[id];\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\ngantt._autoSchedulingPath = {\r\n\tgetKey: function(rel){\r\n\t\treturn rel.lag +\"_\"+ rel.link +\"_\"+ rel.source +\"_\"+ rel.target;\r\n\t},\r\n\tgetVirtualRoot: function(){\r\n\t\treturn gantt.mixin(\r\n\t\t\tgantt.getSubtaskDates(),\r\n\t\t\t{\r\n\t\t\t\tid: gantt.config.root_id,\r\n\t\t\t\ttype: gantt.config.types.project,\r\n\t\t\t\t$source: [],\r\n\t\t\t\t$target: [],\r\n\t\t\t\t$virtual: true\r\n\t\t\t}\r\n\t\t);\r\n\t},\r\n\r\n\tfilterDuplicates: function(relations){\r\n\t\tvar keys = {};\r\n\t\tfor(var i = 0; i < relations.length; i++){\r\n\t\t\tvar key = this.getKey(relations[i]);\r\n\t\t\tif(keys[key]){\r\n\t\t\t\trelations.splice(i, 1);\r\n\t\t\t\ti--;\r\n\t\t\t}else{\r\n\t\t\t\tkeys[key] = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn relations;\r\n\t},\r\n\r\n\tgetLinkedTasks: function(id, includePredecessors){\r\n\t\tvar startIds = [id];\r\n\r\n\t\t//TODO: format links cache\r\n\t\tvar clearCache = false;\r\n\t\tif(!gantt._isLinksCacheEnabled()) {\r\n\t\t\tgantt._startLinksCache();\r\n\t\t\tclearCache = true;\r\n\t\t}\r\n\t\tvar relations = [];\r\n\t\tvar visited = {};\r\n\t\tfor(var i = 0; i < startIds.length; i++){\r\n\t\t\tthis._getLinkedTasks(startIds[i], visited, includePredecessors);\r\n\t\t}\r\n\r\n\t\tfor(var i in visited){\r\n\t\t\trelations.push(visited[i]);\r\n\t\t}\r\n\t\tif(clearCache)\r\n\t\t\tgantt._endLinksCache();\r\n\t\treturn relations;\r\n\t},\r\n\r\n\t_getLinkedTasks: function(rootTask, visitedTasks, includePredecessors, isChild) {\r\n\t\tvar from = rootTask === undefined ? gantt.config.root_id : rootTask;\r\n\t\tvar visited = visitedTasks || {};\r\n\r\n\t\tvar rootObj = gantt.isTaskExists(from) ? gantt.getTask(from) : this.getVirtualRoot();\r\n\r\n\t\tvar successors = gantt._getSuccessors(rootObj, isChild);\r\n\r\n\t\tvar predecessors = [];\r\n\t\tif (includePredecessors) {\r\n\t\t\tpredecessors = gantt._getPredecessors(rootObj, isChild);\r\n\t\t}\r\n\t\tvar relations = [];\r\n\t\tvar linkKey;\r\n\r\n\t\tfor(var i = 0; i < successors.length; i++){\r\n\t\t\tlinkKey = this.getKey(successors[i]);\r\n\t\t\tif(visited[linkKey]) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}else{\r\n\t\t\t\tvisited[linkKey] = successors[i];\r\n\t\t\t\trelations.push(successors[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor(var i = 0; i < predecessors.length; i++){\r\n\t\t\tlinkKey = this.getKey(predecessors[i]);\r\n\t\t\tif(visited[linkKey]) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}else{\r\n\t\t\t\tvisited[linkKey] = predecessors[i];\r\n\t\t\t\trelations.push(predecessors[i]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor(var i=0; i < relations.length; i++){\r\n\t\t\tvar isSameParent = relations[i].sourceParent == relations[i].targetParent;\r\n\t\t\tthis._getLinkedTasks(relations[i].target, visited, true, isSameParent);\r\n\t\t}\r\n\r\n\t\tif(gantt.hasChild(rootObj.id)){\r\n\t\t\tvar children = gantt.getChildren(rootObj.id);\r\n\t\t\tfor(var i=0; i < children.length; i++){\r\n\t\t\t\tthis._getLinkedTasks(children[i], visited, true, true);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn relations;\r\n\t},\r\n\r\n\tfindLoops: function(relations){\r\n\r\n\t\tvar cycles = [];\r\n\r\n\t\thelpers.forEach(relations, function(rel){\r\n\t\t\tif(rel.target == rel.source)\r\n\t\t\t\tcycles.push([rel.target, rel.source]);\r\n\t\t});\r\n\r\n\t\tvar graph =  gantt._autoSchedulingGraph;\r\n\t\tvar vertices = graph.getVertices(relations);\r\n\r\n\t\tvar connectedComponents = graph.tarjanStronglyConnectedComponents(vertices, relations);\r\n\r\n\t\thelpers.forEach(connectedComponents, function(component){\r\n\t\t\tif(component.tasks.length > 1){\r\n\t\t\t\tcycles.push(component);//{ tasks: [task ids], links: [links ids]}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn cycles;\r\n\t\t//{task:id, link:link.type, lag: link.lag || 0, source: link.source}\r\n\t}\r\n};\r\n\r\ngantt._autoSchedulingDateResolver = {\r\n\tisFirstSmaller: function(small, big, task){\r\n\t\tif(small.valueOf() < big.valueOf() && gantt._hasDuration(small, big, task))\r\n\t\t\treturn true;\r\n\t\treturn false;\r\n\t},\r\n\r\n\tisSmallerOrDefault: function(smallDate, bigDate, task){\r\n\t\treturn !!(!smallDate || this.isFirstSmaller(smallDate, bigDate, task));\r\n\t},\r\n\r\n\tresolveRelationDate: function(taskId, relations, getEndDate){\r\n\t\tvar minStart = null;\r\n\t\tvar linkId = null;\r\n\r\n\t\tvar defaultStart = null;\r\n\t\tvar task;\r\n\t\tfor(var i = 0; i < relations.length; i++){\r\n\t\t\tvar relation = relations[i];\r\n\t\t\ttaskId = relation.target;\r\n\r\n\t\t\tdefaultStart = relation.preferredStart;\r\n\t\t\ttask = gantt.getTask(taskId);\r\n\t\t\tvar constraintDate = this.getConstraintDate(relation, getEndDate, task);\r\n\r\n\r\n\t\t\tif(this.isSmallerOrDefault(defaultStart, constraintDate, task) && this.isSmallerOrDefault(minStart, constraintDate, task)){\r\n\t\t\t\tminStart = constraintDate;\r\n\t\t\t\tlinkId = relation.id;\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif(minStart){\r\n\t\t\tminStart = gantt.getClosestWorkTime({date:minStart, dir:\"future\", task:gantt.getTask(taskId)});\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tlink: linkId,\r\n\t\t\ttask: taskId,\r\n\t\t\tstart_date: minStart\r\n\t\t};\r\n\t},\r\n\tgetConstraintDate: function(relation, getEndDate, task){\r\n\t\tvar predecessorEnd = getEndDate(relation.source);\r\n\t\tvar successor = task;\r\n\r\n\t\tvar successorStart = gantt.getClosestWorkTime({date:predecessorEnd, dir:\"future\", task:successor});\r\n\r\n\t\tif(predecessorEnd && relation.lag && relation.lag*1 == relation.lag){\r\n\t\t\tsuccessorStart = gantt.calculateEndDate({start_date: predecessorEnd, duration: relation.lag*1, task: successor});\r\n\t\t}\r\n\r\n\t\treturn successorStart;\r\n\t}\r\n};\r\n\r\ngantt._autoSchedulingPlanner = {\r\n\tgeneratePlan: function(relations){\r\n\r\n\t\tvar graph = gantt._autoSchedulingGraph;\r\n\t\tvar orderedIds = graph.topologicalSort(relations);\r\n\t\tvar predecessorRelations = {},\r\n\t\t\tplansHash = {};\r\n\r\n\t\tvar id;\r\n\t\tfor(var i = 0, len = orderedIds.length; i < len; i++){\r\n\t\t\tid = orderedIds[i];\r\n\t\t\tvar task = gantt.getTask(id);\r\n\t\t\tif(task.auto_scheduling === false){\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tpredecessorRelations[id] = [];\r\n\t\t\tplansHash[id] = null;\r\n\t\t}\r\n\r\n\t\tfunction getPredecessorEndDate(id){\r\n\t\t\tvar plan = plansHash[id];\r\n\t\t\tvar task = gantt.getTask(id);\r\n\t\t\tvar res;\r\n\r\n\t\t\tif(!(plan && (plan.start_date || plan.end_date))){\r\n\t\t\t\tres = task.end_date;\r\n\t\t\t}else if(plan.end_date){\r\n\t\t\t\tres = plan.end_date;\r\n\t\t\t}else {\r\n\t\t\t\tres = gantt.calculateEndDate({start_date: plan.start_date, duration: task.duration, task: task});\r\n\t\t\t}\r\n\r\n\t\t\treturn res;\r\n\t\t}\r\n\r\n\t\tvar rel;\r\n\t\tfor(var i = 0, len = relations.length; i < len; i++){\r\n\t\t\trel = relations[i];\r\n\t\t\tif(predecessorRelations[rel.target]) {\r\n\t\t\t\tpredecessorRelations[rel.target].push(rel);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar dateResolver = gantt._autoSchedulingDateResolver;\r\n\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < orderedIds.length; i++){\r\n\t\t\tvar currentId = orderedIds[i];\r\n\r\n\t\t\tvar plan = dateResolver.resolveRelationDate(currentId, predecessorRelations[currentId] || [], getPredecessorEndDate);\r\n\r\n\r\n\t\t\tif(plan.start_date && gantt.isLinkExists(plan.link)){\r\n\t\t\t\tvar link = gantt.getLink(plan.link);\r\n\t\t\t\tvar task = gantt.getTask(currentId);\r\n\t\t\t\tvar predecessor = gantt.getTask(link.source);\r\n\r\n\t\t\t\tif (task.start_date.valueOf() !== plan.start_date.valueOf() && gantt.callEvent(\"onBeforeTaskAutoSchedule\", [task, plan.start_date, link, predecessor]) === false) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tplansHash[currentId] = plan;\r\n\t\t\tif(plan.start_date){\r\n\t\t\t\tresult.push(plan);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t},\r\n\r\n\tapplyProjectPlan: function(projectPlan){\r\n\t\tvar plan, task, link, predecessor;\r\n\r\n\t\tvar updateTasks = [];\r\n\t\tfor(var i = 0; i <  projectPlan.length; i++){\r\n\t\t\tlink = null;\r\n\t\t\tpredecessor = null;\r\n\t\t\tplan = projectPlan[i];\r\n\r\n\t\t\tif(!plan.task) continue;\r\n\r\n\t\t\ttask = gantt.getTask(plan.task);\r\n\t\t\tif(plan.link){\r\n\t\t\t\tlink = gantt.getLink(plan.link);\r\n\t\t\t\tpredecessor = gantt.getTask(link.source);\r\n\t\t\t}\r\n\r\n\t\t\tvar newDate = null;\r\n\t\t\tif(plan.start_date && (task.start_date.valueOf() != plan.start_date.valueOf())){\r\n\t\t\t\tnewDate = plan.start_date;\r\n\t\t\t}\r\n\r\n\t\t\tif(!newDate) continue;\r\n\t\t\t\r\n\t\t\ttask.start_date = newDate;\r\n\t\t\ttask.end_date = gantt.calculateEndDate(task);\r\n\r\n\t\t\tupdateTasks.push(task.id);\r\n\t\t\tgantt.callEvent(\"onAfterTaskAutoSchedule\", [task, newDate, link, predecessor]);\r\n\r\n\t\t}\r\n\t\treturn updateTasks;\r\n\t}\r\n};\r\n\r\ngantt._autoSchedulingPreferredDates = function(startTask, relations){\r\n\tfor(var i = 0; i < relations.length; i++){\r\n\t\tvar rel = relations[i];\r\n\t\tvar task = gantt.getTask(rel.target);\r\n\r\n\t\tif(!gantt.config.auto_scheduling_strict || rel.target == startTask){\r\n\t\t\trel.preferredStart = new Date(task.start_date);\r\n\t\t}\r\n\t}\r\n};\r\n\r\ngantt._autoSchedule = function(id, relations, updateCallback){\r\n\tif (gantt.callEvent(\"onBeforeAutoSchedule\", [id]) === false) {\r\n\t\treturn;\r\n\t}\r\n\tgantt._autoscheduling_in_progress = true;\r\n\r\n\tvar path = gantt._autoSchedulingPath;\r\n\r\n\tvar updatedTasks = [];\r\n\r\n\tvar cycles = path.findLoops(relations);\r\n\tif(cycles.length){\r\n\t\tgantt.callEvent(\"onAutoScheduleCircularLink\", [cycles]);\r\n\t}else{\r\n\r\n\t\tvar planner = gantt._autoSchedulingPlanner;\r\n\t\tgantt._autoSchedulingPreferredDates(id, relations);\r\n\r\n\t\tvar plan = planner.generatePlan(relations);\r\n\t\tupdatedTasks = planner.applyProjectPlan(plan);\r\n\r\n\t\tif(updateCallback){\r\n\t\t\tupdateCallback(updatedTasks);\r\n\t\t}\r\n\t}\r\n\r\n\tgantt._autoscheduling_in_progress = false;\r\n\tgantt.callEvent(\"onAfterAutoSchedule\", [id, updatedTasks]);\r\n\r\n\treturn updatedTasks;\r\n};\r\n\r\ngantt.autoSchedule = function(id, inclusive){\r\n\r\n\tif(inclusive === undefined){\r\n\t\tinclusive = true;\r\n\t}else{\r\n\t\tinclusive = !!inclusive;\r\n\t}\r\n\r\n\tvar relations =  gantt._autoSchedulingPath.getLinkedTasks(id, inclusive);\r\n\r\n\tvar totalRelations = relations.length;\r\n\tvar startAutoSchedule = Date.now();\r\n\tgantt._autoSchedule(id, relations, gantt._finalizeAutoSchedulingChanges);\r\n\tvar durationAutoSchedule = Date.now() - startAutoSchedule;\r\n};\r\n\r\ngantt._finalizeAutoSchedulingChanges = function(updatedTasks){\r\n\tfunction resetTime(task){\r\n\t\tif(batchUpdate)\r\n\t\t\treturn;\r\n\r\n\t\tvar start = task.start_date.valueOf(),\r\n\t\t\tend = task.end_date.valueOf();\r\n\r\n\t\tgantt.resetProjectDates(task);\r\n\t\tif(task.start_date.valueOf() != start || task.end_date.valueOf() != end){\r\n\t\t\tbatchUpdate = true;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tvar children = gantt.getChildren(task.id);\r\n\t\tfor(var i = 0; !batchUpdate && i < children.length; i++){\r\n\t\t\tresetTime(gantt.getTask(children[i]));\r\n\t\t}\r\n\t}\r\n\r\n\tvar batchUpdate = false;\r\n\t// call batchUpdate (full repaint) only if we update multiple tasks,\r\n\tif(updatedTasks.length == 1){\r\n\t\tgantt.eachParent(resetTime, updatedTasks[0]);\r\n\t}else if(updatedTasks.length){\r\n\t\tbatchUpdate = true;\r\n\t}\r\n\r\n\tfunction payload(){\r\n\t\tfor(var i = 0; i < updatedTasks.length; i++){\r\n\t\t\tgantt.updateTask(updatedTasks[i]);\r\n\t\t}\r\n\t}\r\n\tif(batchUpdate){\r\n\t\tgantt.batchUpdate(payload);\r\n\t}else{\r\n\t\tpayload();\r\n\t}\r\n\r\n};\r\n\r\ngantt.isCircularLink = function(link){\r\n\treturn !!gantt._getConnectedGroup(link);\r\n\r\n};\r\n\r\ngantt._getConnectedGroup = function(link){\r\n\tvar manager = gantt._autoSchedulingPath;\r\n\r\n\tvar allRelations = manager.getLinkedTasks();\r\n\tif(!gantt.isLinkExists(link.id)){\r\n\t\tallRelations = allRelations.concat(gantt._formatLink(link));\r\n\t}\r\n\r\n\tvar cycles = manager.findLoops(allRelations);\r\n\r\n\tvar found = false;\r\n\tfor(var i = 0; (i < cycles.length) && !found; i++){\r\n\t\tvar links = cycles[i].links;\r\n\t\tfor(var j = 0; j < links.length; j++){\r\n\t\t\tif(links[j] == link.id){\r\n\t\t\t\treturn cycles[i];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn null;\r\n};\r\n\r\ngantt.findCycles = function(){\r\n\tvar manager = gantt._autoSchedulingPath;\r\n\r\n\tvar allRelations = manager.getLinkedTasks();\r\n\treturn manager.findLoops(allRelations);\r\n};\r\n\r\ngantt._attachAutoSchedulingHandlers = function(){\r\n\r\n\tgantt._autoScheduleAfterLinkChange = function (linkId, link) {\r\n\t\tif (gantt.config.auto_scheduling && !this._autoscheduling_in_progress) {\r\n\t\t\tgantt.autoSchedule(link.source);\r\n\t\t}\r\n\t};\r\n\r\n\tgantt.attachEvent(\"onAfterLinkUpdate\", gantt._autoScheduleAfterLinkChange);\r\n\tgantt.attachEvent(\"onAfterLinkAdd\", gantt._autoScheduleAfterLinkChange);\r\n\r\n\tgantt.attachEvent(\"onAfterLinkDelete\", function(id, link){\r\n\t\tif (this.config.auto_scheduling && !this._autoscheduling_in_progress && this.isTaskExists(link.target)) {\r\n\t\t\t// after link deleted - auto schedule target for other relations that may be left\r\n\t\t\tvar target = this.getTask(link.target);\r\n\t\t\tvar predecessors = this._getPredecessors(target);\r\n\t\t\tif(predecessors.length){\r\n\t\t\t\tthis.autoSchedule(predecessors[0].source, false);\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\r\n\tgantt.attachEvent(\"onParse\", function(){\r\n\t\tif (gantt.config.auto_scheduling && gantt.config.auto_scheduling_initial) {\r\n\t\t\tgantt.autoSchedule();\r\n\t\t}\r\n\t});\r\n\r\n\tgantt._preventCircularLink = function(id, link){\r\n\t\tif(gantt.isCircularLink(link)){\r\n\t\t\tgantt.callEvent(\"onCircularLinkError\", [link, gantt._getConnectedGroup(link)]);\r\n\t\t\treturn false;\r\n\t\t}else{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t};\r\n\r\n\tgantt._preventDescendantLink = function(id, link){\r\n\t\tvar source = gantt.getTask(link.source),\r\n\t\t\ttarget = gantt.getTask(link.target);\r\n\r\n\t\tif(!gantt.config.auto_scheduling_descendant_links){\r\n\t\t\tif((gantt.isChildOf(source.id, target.id) && gantt.isSummaryTask(target)) || (gantt.isChildOf(target.id, source.id) && gantt.isSummaryTask(source))){\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t};\r\n\r\n\tgantt.attachEvent(\"onBeforeLinkAdd\", gantt._preventCircularLink);\r\n\tgantt.attachEvent(\"onBeforeLinkAdd\", gantt._preventDescendantLink);\r\n\tgantt.attachEvent(\"onBeforeLinkUpdate\", gantt._preventCircularLink);\r\n\tgantt.attachEvent(\"onBeforeLinkUpdate\", gantt._preventDescendantLink);\r\n\r\n\tgantt._datesNotEqual = function(dateA, dateB, taskA, taskB){\r\n\t\tif(dateA.valueOf() > dateB.valueOf()){\r\n\t\t\treturn this._hasDuration({start_date: dateB, end_date: dateA, task: taskB});\r\n\t\t}else{\r\n\t\t\treturn this._hasDuration({start_date: dateA, end_date: dateB, task: taskA});\r\n\t\t}\r\n\t};\r\n\tgantt._notEqualTaskDates = function(task1, task2){\r\n\t\tif (this._datesNotEqual(task1.start_date, task2.start_date, task1, task2) ||\r\n\t\t\t((this._datesNotEqual(task1.end_date, task2.end_date, task1, task2) ||\r\n\t\t\t\ttask1.duration != task2.duration) && task1.type != gantt.config.types.milestone)) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t};\r\n\r\n\tvar relations;\r\n\tvar movedTask;\r\n\tgantt.attachEvent(\"onBeforeTaskDrag\", function(id, mode, task){\r\n\t\tif(gantt.config.auto_scheduling && gantt.config.auto_scheduling_move_projects){\r\n\t\t\t// collect relations before drag and drop  in order to have original positions of subtasks within project since they are used as lag when moving dependent project\r\n\t\t\trelations = gantt._autoSchedulingPath.getLinkedTasks(id, true);\r\n\t\t\tmovedTask = id;\r\n\t\t}\r\n\t\treturn true;\r\n\t});\r\n\r\n\tfunction resetToStartLinksLags(taskId, relations){\r\n\t\tvar skipped = false;\r\n\t\tfor(var i = 0; i < relations.length; i++){\r\n\t\t\tvar originalLink = gantt.getLink(relations[i].id);\r\n\t\t\tif(originalLink.type == gantt.config.links.start_to_start || originalLink.type == gantt.config.links.start_to_finish){\r\n\t\t\t\trelations.splice(i, 1);\r\n\t\t\t\ti--;\r\n\t\t\t\tskipped = true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif(skipped){\r\n\t\t\tvar presentLinks = {};\r\n\t\t\tfor(var i = 0; i < relations.length; i++){\r\n\t\t\t\tpresentLinks[relations[i].id] = true;\r\n\t\t\t}\r\n\r\n\t\t\tvar updatedLinks = gantt._autoSchedulingPath.getLinkedTasks(taskId, true);\r\n\t\t\tfor(var i = 0; i < updatedLinks.length; i++){\r\n\t\t\t\tif(!presentLinks[updatedLinks[i].id]){\r\n\t\t\t\t\trelations.push(updatedLinks[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tgantt._autoScheduleAfterDND = function(taskId, task){\r\n\t\tif (gantt.config.auto_scheduling && !this._autoscheduling_in_progress) {\r\n\t\t\tvar newTask = this.getTask(taskId);\r\n\t\t\tif (gantt._notEqualTaskDates(task, newTask)){\r\n\t\t\t\tif(gantt.config.auto_scheduling_move_projects && movedTask == taskId){\r\n\r\n\t\t\t\t\tif(gantt.calculateDuration(task) != gantt.calculateDuration(newTask)){\r\n\t\t\t\t\t\t// task duration is used as lag when converting start_to_start and start_to_finish into finish to start links\r\n\t\t\t\t\t\t// recalculate these links if task duration has changed\r\n\t\t\t\t\t\tresetToStartLinksLags(taskId, relations);\r\n\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t\tgantt._autoSchedule(taskId, relations, gantt._finalizeAutoSchedulingChanges);\r\n\t\t\t\t}else{\r\n\t\t\t\t\tgantt.autoSchedule(newTask.id);\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t}\r\n\t\t}\r\n\t\trelations = null;\r\n\t\tmovedTask = null;\r\n\t\treturn true;\r\n\t};\r\n\r\n\tgantt._lightBoxChangesHandler = function (taskId, task) {\r\n\t\tif (gantt.config.auto_scheduling && !this._autoscheduling_in_progress) {\r\n\t\t\tvar oldTask = this.getTask(taskId);\r\n\t\t\tif (gantt._notEqualTaskDates(task, oldTask)) {\r\n\t\t\t\tgantt._autoschedule_lightbox_id = taskId;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t};\r\n\tgantt._lightBoxSaveHandler = function (taskId, task) {\r\n\r\n\t\tif (gantt.config.auto_scheduling && !this._autoscheduling_in_progress) {\r\n\t\t\tif (gantt._autoschedule_lightbox_id && gantt._autoschedule_lightbox_id == taskId) {\r\n\t\t\t\tgantt._autoschedule_lightbox_id = null;\r\n\t\t\t\tgantt.autoSchedule(task.id);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t};\r\n\r\n\r\n\r\n\r\n\tgantt.attachEvent(\"onBeforeTaskChanged\", function(id, mode, task){ return gantt._autoScheduleAfterDND(id, task); });\r\n\tgantt.attachEvent(\"onLightboxSave\", gantt._lightBoxChangesHandler);\r\n\tgantt.attachEvent(\"onAfterTaskUpdate\", gantt._lightBoxSaveHandler);\r\n\r\n\r\n};\r\n\r\n\r\ngantt.attachEvent(\"onGanttReady\", function(){\r\n\tgantt._attachAutoSchedulingHandlers();\r\n\t// attach handlers only when initialized for the first time\r\n\tgantt._attachAutoSchedulingHandlers = function(){};\r\n});\r\n\r\n})();\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/ext/auto_scheduling.js\n// module id = 3\n// module chunks = 1","var units = {\r\n\t\"second\": 1,\r\n\t\"minute\": 60,\r\n\t\"hour\": 60 * 60,\r\n\t\"day\": 60 * 60 * 24,\r\n\t\"week\": 60 * 60 * 24 * 7,\r\n\t\"month\": 60 * 60 * 24 * 30,\r\n\t\"quarter\": 60 * 60 * 24 * 30 * 3,\r\n\t\"year\": 60 * 60 * 24 * 365\r\n};\r\nfunction getSecondsInUnit(unit){\r\n\treturn units[unit] || units.hour;\r\n}\r\n\r\nfunction forEach(arr, callback){\r\n\tif(arr.forEach){\r\n\t\tarr.forEach(callback);\r\n\t}else{\r\n\t\tvar workArray = arr.slice();\r\n\t\tfor(var i = 0; i < workArray.length; i++){\r\n\t\t\tcallback(workArray[i], i);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction arrayMap(arr, callback){\r\n\tif(arr.map){\r\n\t\treturn arr.map(callback);\r\n\t}else{\r\n\t\tvar workArray = arr.slice();\r\n\t\tvar resArray = [];\r\n\r\n\t\tfor(var i = 0; i < workArray.length; i++){\r\n\t\t\tresArray.push(callback(workArray[i], i));\r\n\t\t}\r\n\r\n\t\treturn resArray;\r\n\t}\r\n\r\n}\r\n\r\nmodule.exports = {\r\n\tgetSecondsInUnit: getSecondsInUnit,\r\n\tforEach: forEach,\r\n\tarrayMap: arrayMap\r\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/utils/helpers.js\n// module id = 4\n// module chunks = 1"],"sourceRoot":""}