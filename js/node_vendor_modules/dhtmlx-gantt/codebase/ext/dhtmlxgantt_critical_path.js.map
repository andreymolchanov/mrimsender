{"version":3,"sources":["webpack:///dhtmlxgantt_critical_path.js","webpack:///webpack/bootstrap 9278c35520642ffbe1b9","webpack:///./sources/core/links_common.js","webpack:///./sources/ext/critical_path.js"],"names":["Gantt","plugin","gantt","modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_get_linked_task","link","getTarget","task","taskId","target","source","isTaskExists","getTask","_get_link_target","_get_link_source","caching","formattedLinksStash","inheritedSuccessorsStash","inheritedPredecessorsStash","getPredecessorsCache","_isLinksCacheEnabled","_startLinksCache","_endLinksCache","_formatLink","id","relations","this","isSummaryTask","isChildOf","from","_getImplicitLinks","respectTargetOffset","config","auto_scheduling_move_projects","targetDates","getSubtaskDates","start_date","end_date","to","$target","length","getState","drag_id","calculateDuration","fromLength","fromTask","j","toLength","toTask","lag","subtaskLink","type","push","_convertToFinishToStartLink","taskParent","_isAutoSchedulable","auto_scheduling","parent","selectOffset","selectSourceLinks","children","eachTask","skipChild","linksCollection","$source","siblingLink","getLink","siblingId","_getDirectDependencies","selectSuccessors","links","successors","linksIds","concat","_getInheritedDependencies","cacheCollection","stop","inheritedRelations","getParent","eachParent","apply","parentDependencies","_getDirectSuccessors","_getInheritedSuccessors","_getDirectPredecessors","_getInheritedPredecessors","_getSuccessors","skipInherited","_getPredecessors","result","key","predecessors","sourceTask","targetTask","sourceParent","targetParent","res","finish_to_start","preferredStart","additionalLag","start_to_start","duration","finish_to_finish","start_to_finish","highlight_critical_path","_criticalPathHandler","render","attachEvent","_isCriticalTask","chain","path","_isProjectEnd","clearCache","_getDependencies","next","_getSlack","isCriticalTask","assert","undefined","isCriticalLink","getSlack","task1","task2","common","slacks","Math","min","next_task","relation","types","getTaskType","milestone","_getProjectEnd","tasks","getTaskByTime","sort","a","b","_hasDuration","_getSummaryPredecessors"],"mappings":"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","file":"dhtmlxgantt_critical_path.js","sourcesContent":["/*!\n * @license\r\n * \r\n * dhtmlxGantt v.5.1.5 Professional\r\n * This software is covered by DHTMLX Enterprise License. Usage without proper license is prohibited.\r\n * \r\n * (c) Dinamenta, UAB.\r\n * \n */\nGantt.plugin(function(gantt){\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 5);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */,\n/* 1 */\n/***/ (function(module, exports) {\n\nmodule.exports = function(gantt) {\r\n// helpers for building chain of dependencies, used for critical path calculation and for auto scheduling\r\n\r\n\tgantt._get_linked_task = function (link, getTarget) {\r\n\t\tvar task = null;\r\n\t\tvar taskId = getTarget ? link.target : link.source;\r\n\r\n\t\tif (gantt.isTaskExists(taskId)) {\r\n\t\t\ttask = gantt.getTask(taskId);\r\n\t\t}\r\n\r\n\t\treturn task;\r\n\t};\r\n\tgantt._get_link_target = function (link) {\r\n\t\treturn gantt._get_linked_task(link, true);\r\n\t};\r\n\r\n\tgantt._get_link_source = function (link) {\r\n\t\treturn gantt._get_linked_task(link, false);\r\n\t};\r\n\r\n\tvar caching = false;\r\n\tvar formattedLinksStash = {};\r\n\tvar inheritedSuccessorsStash = {};\r\n\tvar inheritedPredecessorsStash = {};\r\n\tvar getPredecessorsCache = {};\r\n\r\n\r\n\tgantt._isLinksCacheEnabled = function(){\r\n\t\treturn caching;\r\n\t};\r\n\tgantt._startLinksCache = function(){\r\n\t\tformattedLinksStash = {};\r\n\t\tinheritedSuccessorsStash = {};\r\n\t\tinheritedPredecessorsStash = {};\r\n\t\tgetPredecessorsCache = {};\r\n\t\tcaching = true;\r\n\t};\r\n\tgantt._endLinksCache = function(){\r\n\t\tformattedLinksStash = {};\r\n\t\tinheritedSuccessorsStash = {};\r\n\t\tinheritedPredecessorsStash = {};\r\n\t\tgetPredecessorsCache = {};\r\n\t\tcaching = false;\r\n\t};\r\n\r\n\tgantt._formatLink = function (link) {\r\n\r\n\r\n\t\tif(caching && formattedLinksStash[link.id]){\r\n\t\t\treturn formattedLinksStash[link.id];\r\n\t\t}\r\n\r\n\t\tvar relations = [];\r\n\t\tvar target = this._get_link_target(link);\r\n\t\tvar source = this._get_link_source(link);\r\n\r\n\t\tif (!(source && target)) {\r\n\t\t\treturn relations;\r\n\t\t}\r\n\r\n\t\tif ((gantt.isSummaryTask(target) && gantt.isChildOf(source.id, target.id)) || (gantt.isSummaryTask(source) && gantt.isChildOf(target.id, source.id))) {\r\n\t\t\treturn relations;\r\n\t\t}\r\n\r\n\r\n\t\t// there are three kinds of connections at this point\r\n\t\t// task -> task - regular link\r\n\t\t// task -> project - transform it into set of regular links (task -> [each subtask]), use offset beetween subtask and project dates as lag, in order not to change mutual positions of subtasks inside a project\r\n\t\t// project -> task - transform it into ([each subtask] -> task) links\r\n\t\t// project -> project - transform it into ([each subtask of p1] -> [each subtask of p2]) links\r\n\r\n\t\tvar from = this._getImplicitLinks(link, source, function (c) {\r\n\t\t\treturn 0;\r\n\t\t}, true);\r\n\r\n\t\tvar respectTargetOffset = gantt.config.auto_scheduling_move_projects;\r\n\t\tvar targetDates = this.isSummaryTask(target) ? this.getSubtaskDates(target.id) : {\r\n\t\t\tstart_date: target.start_date,\r\n\t\t\tend_date: target.end_date\r\n\t\t};\r\n\t\tvar to = this._getImplicitLinks(link, target, function (c) {\r\n\t\t\tif (!respectTargetOffset) {\r\n\t\t\t\treturn 0;\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif (!c.$target.length && !(gantt.getState().drag_id == c.id)) {// drag_id - virtual lag shouldn't restrict task that is being moved inside project\r\n\t\t\t\t\treturn gantt.calculateDuration({\r\n\t\t\t\t\t\tstart_date: targetDates.start_date,\r\n\t\t\t\t\t\tend_date: c.start_date,\r\n\t\t\t\t\t\ttask: source\r\n\t\t\t\t\t});\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn 0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tfor (var i = 0, fromLength = from.length; i < fromLength; i++) {\r\n\t\t\tvar fromTask = from[i];\r\n\t\t\tfor (var j = 0, toLength = to.length; j < toLength; j++) {\r\n\t\t\t\tvar toTask = to[j];\r\n\r\n\t\t\t\tvar lag = fromTask.lag * 1 + toTask.lag * 1;\r\n\r\n\t\t\t\tvar subtaskLink = {\r\n\t\t\t\t\tid: link.id,\r\n\t\t\t\t\ttype: link.type,\r\n\t\t\t\t\tsource: fromTask.task,\r\n\t\t\t\t\ttarget: toTask.task,\r\n\t\t\t\t\tlag: (link.lag * 1 || 0) + lag\r\n\t\t\t\t};\r\n\r\n\t\t\t\trelations.push(gantt._convertToFinishToStartLink(toTask.task, subtaskLink, source, target, fromTask.taskParent, toTask.taskParent));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif(caching)\r\n\t\t\tformattedLinksStash[link.id] = relations;\r\n\r\n\t\treturn relations;\r\n\t};\r\n\r\ngantt._isAutoSchedulable = function(task){\r\n\treturn task.auto_scheduling !== false;\r\n};\r\n\r\ngantt._getImplicitLinks = function(link, parent, selectOffset, selectSourceLinks){\r\n\tvar relations = [];\r\n\r\n\tif(this.isSummaryTask(parent)){\r\n\r\n\t\t// if the summary task contains multiple chains of linked tasks - no need to consider every task of the chain,\r\n\t\t// it will be enough to check the first/last tasks of the chain\r\n\t\t// special conditions if there are unscheduled tasks in the chain, or negative lag values\r\n\t\tvar children = {};\r\n\t\tthis.eachTask(function(c){\r\n\t\t\tif(!this.isSummaryTask(c)){\r\n\t\t\t\tchildren[c.id] = c;\r\n\t\t\t}\r\n\t\t}, parent.id);\r\n\r\n\t\tvar skipChild;\r\n\r\n\t\tfor(var c in children){\r\n\t\t\tvar task = children[c];\r\n\t\t\tvar linksCollection = selectSourceLinks ? task.$source : task.$target;\r\n\r\n\t\t\tskipChild = false;\r\n\r\n\t\t\tfor(var l = 0; l < linksCollection.length; l++){\r\n\t\t\t\tvar siblingLink = gantt.getLink(linksCollection[l]);\r\n\t\t\t\tvar siblingId = selectSourceLinks ? siblingLink.target : siblingLink.source;\r\n\r\n\t\t\t\tif(children[siblingId] && task.auto_scheduling !== false && children[siblingId].auto_scheduling !== false && siblingLink.lag >= 0){\r\n\t\t\t\t\tskipChild = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(!skipChild){\r\n\t\t\t\trelations.push({task: task.id, taskParent: task.parent, lag: selectOffset(task)});\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}else{\r\n\t\trelations.push({task:parent.id, taskParent: parent.parent, lag: 0});\r\n\t}\r\n\r\n\t\treturn relations;\r\n};\r\n\r\n\tgantt._getDirectDependencies = function (task, selectSuccessors) {\r\n\r\n\t\tvar links = [],\r\n\t\t\tsuccessors = [];\r\n\r\n\t\tvar linksIds = selectSuccessors ? task.$source : task.$target;\r\n\r\n\tfor(var i = 0; i < linksIds.length; i++){\r\n\t\tvar link = this.getLink(linksIds[i]);\r\n\t\tif(this.isTaskExists(link.source) && this.isTaskExists(link.target)) {\r\n\t\t\tvar target = this.getTask(link.target);\r\n\t\t\tif(this._isAutoSchedulable(target)){\r\n\t\t\t\tlinks.push(this.getLink(linksIds[i]));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t\tfor (var i = 0; i < links.length; i++) {\r\n\t\t\tsuccessors = successors.concat(this._formatLink(links[i]));\r\n\t\t}\r\n\r\n\t\treturn successors;\r\n\t};\r\n\r\n\tgantt._getInheritedDependencies = function (task, selectSuccessors) {\r\n\r\n\t\t//var successors = [];\r\n\tvar stop = false;\r\n\tvar inheritedRelations = [];\r\n\tvar cacheCollection;\r\n\tif(this.isTaskExists(task.id)){\r\n\r\n\t\tvar parent = this.getParent(task.id);\r\n\r\n\r\n\t\tthis.eachParent(function(parent){\r\n\t\t\tif(stop)\r\n\t\t\t\treturn;\r\n\r\n\t\t\tif(caching){\r\n\t\t\t\tcacheCollection = selectSuccessors ? inheritedSuccessorsStash : inheritedPredecessorsStash;\r\n\t\t\t\tif(cacheCollection[parent.id]){\r\n\t\t\t\t\tinheritedRelations.push.apply(inheritedRelations, cacheCollection[parent.id]);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tvar parentDependencies;\r\n\t\t\tif(this.isSummaryTask(parent)){\r\n\t\t\t\tif(!this._isAutoSchedulable(parent)){\r\n\t\t\t\t\tstop = true;\r\n\t\t\t\t}else{\r\n\t\t\t\t\tparentDependencies = this._getDirectDependencies(parent, selectSuccessors);\r\n\t\t\t\t\tif(caching){\r\n\t\t\t\t\t\tcacheCollection[parent.id] = parentDependencies;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tinheritedRelations.push.apply(inheritedRelations, parentDependencies);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t}, task.id, this);\r\n\r\n\t\t//\tfor (var i = 0; i < inheritedRelations.length; i++) {\r\n\t\t//\t\tsuccessors.push(inheritedRelations[i]);\r\n\t\t//\t}\r\n\t\t}\r\n\r\n\t\treturn inheritedRelations;\r\n\t};\r\n\r\n\r\n\tgantt._getDirectSuccessors = function (task) {\r\n\t\treturn this._getDirectDependencies(task, true);\r\n\t};\r\n\r\n\tgantt._getInheritedSuccessors = function (task) {\r\n\t\treturn this._getInheritedDependencies(task, true);\r\n\t};\r\n\r\n\tgantt._getDirectPredecessors = function (task) {\r\n\t\treturn this._getDirectDependencies(task, false);\r\n\t};\r\n\r\n\tgantt._getInheritedPredecessors = function (task) {\r\n\t\treturn this._getInheritedDependencies(task, false);\r\n\t};\r\n\r\n\tgantt._getSuccessors = function (task, skipInherited) {\r\n\t\tvar successors = this._getDirectSuccessors(task);\r\n\t\tif(skipInherited){\r\n\t\t\treturn successors;\r\n\t\t}else{\r\n\t\t\treturn successors.concat(this._getInheritedSuccessors(task));\r\n\t\t}\r\n\t};\r\n\r\n\tgantt._getPredecessors = function (task, skipInherited) {\r\n\t\tvar key = task.id + skipInherited;\r\n\t\tvar result;\r\n\r\n\t\tif(caching && getPredecessorsCache[key]){\r\n\t\t\treturn getPredecessorsCache[key];\r\n\t\t}\r\n\r\n\t\tvar predecessors = this._getDirectPredecessors(task);\r\n\t\tif(skipInherited){\r\n\t\t\tresult = predecessors;\r\n\t\t}else{\r\n\t\t\tresult = predecessors.concat(this._getInheritedPredecessors(task));\r\n\t\t}\r\n\t\tif(caching){\r\n\t\t\tgetPredecessorsCache[key] = result;\r\n\t\t}\r\n\t\treturn result;\r\n\t};\r\n\r\n\r\n\tgantt._convertToFinishToStartLink = function (id, link, sourceTask, targetTask, sourceParent, targetParent) {\r\n\t\t// convert finish-to-finish, start-to-finish and start-to-start to finish-to-start link and provide some additional properties\r\n\t\tvar res = {\r\n\t\t\ttarget: id,\r\n\t\t\tlink: gantt.config.links.finish_to_start,\r\n\t\t\tid: link.id,\r\n\t\t\tlag: link.lag || 0,\r\n\t\t\tsource: link.source,\r\n\t\t\tpreferredStart: null,\r\n\t\t\tsourceParent: sourceParent,\r\n\t\t\ttargetParent: targetParent\r\n\t\t};\r\n\r\n\t\tvar additionalLag = 0;\r\n\t\tswitch (link.type) {\r\n\t\t\tcase gantt.config.links.start_to_start:\r\n\t\t\t\tadditionalLag = -sourceTask.duration;\r\n\t\t\t\tbreak;\r\n\t\t\tcase gantt.config.links.finish_to_finish:\r\n\t\t\t\tadditionalLag = -targetTask.duration;\r\n\t\t\t\tbreak;\r\n\t\t\tcase gantt.config.links.start_to_finish:\r\n\t\t\t\tadditionalLag = -sourceTask.duration - targetTask.duration;\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tadditionalLag = 0;\r\n\t\t}\r\n\r\n\t\tres.lag += additionalLag;\r\n\t\treturn res;\r\n\t};\r\n};\n\n/***/ }),\n/* 2 */,\n/* 3 */,\n/* 4 */,\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(6);\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(1)(gantt);\r\n\r\ngantt.config.highlight_critical_path = false;\r\ngantt._criticalPathHandler = function(){\r\n\tif(gantt.config.highlight_critical_path)\r\n\t\tgantt.render();\r\n};\r\ngantt.attachEvent(\"onAfterLinkAdd\", gantt._criticalPathHandler);\r\ngantt.attachEvent(\"onAfterLinkUpdate\", gantt._criticalPathHandler);\r\ngantt.attachEvent(\"onAfterLinkDelete\", gantt._criticalPathHandler);\r\ngantt.attachEvent(\"onAfterTaskAdd\", gantt._criticalPathHandler);\r\ngantt.attachEvent(\"onAfterTaskUpdate\", gantt._criticalPathHandler);\r\ngantt.attachEvent(\"onAfterTaskDelete\", gantt._criticalPathHandler);\r\n\r\n\r\ngantt._isCriticalTask = function(task, chain){\r\n\tif(!task || !task.id) return;\r\n\tvar path = chain || {};\r\n\r\n\tif(this._isProjectEnd(task)){\r\n\t\treturn true;\r\n\t}else{\r\n\r\n\t\tvar clearCache = false;\r\n\t\tif(!gantt._isLinksCacheEnabled()) {\r\n\t\t\tgantt._startLinksCache();\r\n\t\t\tclearCache = true;\r\n\t\t}\r\n\r\n\t\tpath[task.id] = true;\r\n\t\tvar successors = this._getDependencies(task);\r\n\t\tfor(var i=0; i < successors.length; i++){\r\n\t\t\tvar next = this.getTask(successors[i].target);\r\n\t\t\tif(this._getSlack(task, next, successors[i]) <= 0 && (!path[next.id] && this._isCriticalTask(next, path)))\r\n\t\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tif(clearCache)\r\n\t\t\tgantt._endLinksCache();\r\n\t}\r\n\r\n\treturn false;\r\n};\r\n\r\ngantt.isCriticalTask = function (task) {\r\n\tgantt.assert(!!(task && task.id !== undefined), \"Invalid argument for gantt.isCriticalTask\");\r\n\treturn this._isCriticalTask(task, {});\r\n};\r\n\r\ngantt.isCriticalLink = function (link) {\r\n\treturn this.isCriticalTask(gantt.getTask(link.source));\r\n};\r\n\r\ngantt.getSlack = function(task1, task2){\r\n\tvar relations = [];\r\n\tvar common = {};\r\n\tfor(var i=0; i < task1.$source.length; i++){\r\n\t\tcommon[task1.$source[i]] = true;\r\n\t}\r\n\tfor(var i=0; i < task2.$target.length; i++){\r\n\t\tif(common[task2.$target[i]])\r\n\t\t\trelations.push(task2.$target[i]);\r\n\t}\r\n\r\n\tvar slacks = [];\r\n\tfor(var i=0; i < relations.length; i++){\r\n\t\tvar link = this.getLink(relations[i]);\r\n\t\tslacks.push(this._getSlack(task1, task2, this._convertToFinishToStartLink(link.id, link, task1, task2, task1.parent, task2.parent)));\r\n\t}\r\n\r\n\treturn Math.min.apply(Math, slacks);\r\n};\r\n\r\ngantt._getSlack = function (task, next_task, relation) {\r\n\t// relation - link expressed as finish-to-start (gantt._convertToFinishToStartLink)\r\n\tvar types = this.config.types;\r\n\r\n\tvar from = null;\r\n\tif(this.getTaskType(task.type) == types.milestone){\r\n\t\tfrom = task.start_date;\r\n\t}else{\r\n\t\tfrom = task.end_date;\r\n\t}\r\n\r\n\tvar to = next_task.start_date;\r\n\r\n\tvar duration = 0;\r\n\tif(+from > +to){\r\n\t\tduration = -this.calculateDuration({start_date: to, end_date: from, task: task});\r\n\t}else{\r\n\t\tduration = this.calculateDuration({start_date: from, end_date: to, task: task});\r\n\t}\r\n\r\n\tvar lag = relation.lag;\r\n\tif(lag && lag*1 == lag){\r\n\t\tduration -= lag;\r\n\t}\r\n\r\n\treturn duration;\r\n};\r\n\r\ngantt._getProjectEnd = function () {\r\n\tvar tasks = gantt.getTaskByTime();\r\n\ttasks = tasks.sort(function (a, b) { return +a.end_date > +b.end_date ? 1 : -1; });\r\n\treturn tasks.length ? tasks[tasks.length - 1].end_date : null;\r\n};\r\n\r\ngantt._isProjectEnd = function (task) {\r\n\treturn !(this._hasDuration({start_date:task.end_date, end_date: this._getProjectEnd(), task:task}));\r\n};\r\n\r\ngantt._getSummaryPredecessors = function(task){\r\n\tvar predecessors = [];\r\n\r\n\t// all constraints that are applied to summary parents must be applied to the task\r\n\tthis.eachParent(function(parent){\r\n\t\tif(this.isSummaryTask(parent))\r\n\t\t\tpredecessors = predecessors.concat(gantt._getDependencies(parent));\r\n\t}, task);\r\n\r\n\treturn predecessors;\r\n};\r\n\r\n\r\ngantt._getDependencies = function(task){\r\n\tvar successors = this._getSuccessors(task).concat(\r\n\t\tthis._getSummaryPredecessors(task)\r\n\t);\r\n\treturn successors;\r\n};\r\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// dhtmlxgantt_critical_path.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 9278c35520642ffbe1b9","module.exports = function(gantt) {\r\n// helpers for building chain of dependencies, used for critical path calculation and for auto scheduling\r\n\r\n\tgantt._get_linked_task = function (link, getTarget) {\r\n\t\tvar task = null;\r\n\t\tvar taskId = getTarget ? link.target : link.source;\r\n\r\n\t\tif (gantt.isTaskExists(taskId)) {\r\n\t\t\ttask = gantt.getTask(taskId);\r\n\t\t}\r\n\r\n\t\treturn task;\r\n\t};\r\n\tgantt._get_link_target = function (link) {\r\n\t\treturn gantt._get_linked_task(link, true);\r\n\t};\r\n\r\n\tgantt._get_link_source = function (link) {\r\n\t\treturn gantt._get_linked_task(link, false);\r\n\t};\r\n\r\n\tvar caching = false;\r\n\tvar formattedLinksStash = {};\r\n\tvar inheritedSuccessorsStash = {};\r\n\tvar inheritedPredecessorsStash = {};\r\n\tvar getPredecessorsCache = {};\r\n\r\n\r\n\tgantt._isLinksCacheEnabled = function(){\r\n\t\treturn caching;\r\n\t};\r\n\tgantt._startLinksCache = function(){\r\n\t\tformattedLinksStash = {};\r\n\t\tinheritedSuccessorsStash = {};\r\n\t\tinheritedPredecessorsStash = {};\r\n\t\tgetPredecessorsCache = {};\r\n\t\tcaching = true;\r\n\t};\r\n\tgantt._endLinksCache = function(){\r\n\t\tformattedLinksStash = {};\r\n\t\tinheritedSuccessorsStash = {};\r\n\t\tinheritedPredecessorsStash = {};\r\n\t\tgetPredecessorsCache = {};\r\n\t\tcaching = false;\r\n\t};\r\n\r\n\tgantt._formatLink = function (link) {\r\n\r\n\r\n\t\tif(caching && formattedLinksStash[link.id]){\r\n\t\t\treturn formattedLinksStash[link.id];\r\n\t\t}\r\n\r\n\t\tvar relations = [];\r\n\t\tvar target = this._get_link_target(link);\r\n\t\tvar source = this._get_link_source(link);\r\n\r\n\t\tif (!(source && target)) {\r\n\t\t\treturn relations;\r\n\t\t}\r\n\r\n\t\tif ((gantt.isSummaryTask(target) && gantt.isChildOf(source.id, target.id)) || (gantt.isSummaryTask(source) && gantt.isChildOf(target.id, source.id))) {\r\n\t\t\treturn relations;\r\n\t\t}\r\n\r\n\r\n\t\t// there are three kinds of connections at this point\r\n\t\t// task -> task - regular link\r\n\t\t// task -> project - transform it into set of regular links (task -> [each subtask]), use offset beetween subtask and project dates as lag, in order not to change mutual positions of subtasks inside a project\r\n\t\t// project -> task - transform it into ([each subtask] -> task) links\r\n\t\t// project -> project - transform it into ([each subtask of p1] -> [each subtask of p2]) links\r\n\r\n\t\tvar from = this._getImplicitLinks(link, source, function (c) {\r\n\t\t\treturn 0;\r\n\t\t}, true);\r\n\r\n\t\tvar respectTargetOffset = gantt.config.auto_scheduling_move_projects;\r\n\t\tvar targetDates = this.isSummaryTask(target) ? this.getSubtaskDates(target.id) : {\r\n\t\t\tstart_date: target.start_date,\r\n\t\t\tend_date: target.end_date\r\n\t\t};\r\n\t\tvar to = this._getImplicitLinks(link, target, function (c) {\r\n\t\t\tif (!respectTargetOffset) {\r\n\t\t\t\treturn 0;\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif (!c.$target.length && !(gantt.getState().drag_id == c.id)) {// drag_id - virtual lag shouldn't restrict task that is being moved inside project\r\n\t\t\t\t\treturn gantt.calculateDuration({\r\n\t\t\t\t\t\tstart_date: targetDates.start_date,\r\n\t\t\t\t\t\tend_date: c.start_date,\r\n\t\t\t\t\t\ttask: source\r\n\t\t\t\t\t});\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn 0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tfor (var i = 0, fromLength = from.length; i < fromLength; i++) {\r\n\t\t\tvar fromTask = from[i];\r\n\t\t\tfor (var j = 0, toLength = to.length; j < toLength; j++) {\r\n\t\t\t\tvar toTask = to[j];\r\n\r\n\t\t\t\tvar lag = fromTask.lag * 1 + toTask.lag * 1;\r\n\r\n\t\t\t\tvar subtaskLink = {\r\n\t\t\t\t\tid: link.id,\r\n\t\t\t\t\ttype: link.type,\r\n\t\t\t\t\tsource: fromTask.task,\r\n\t\t\t\t\ttarget: toTask.task,\r\n\t\t\t\t\tlag: (link.lag * 1 || 0) + lag\r\n\t\t\t\t};\r\n\r\n\t\t\t\trelations.push(gantt._convertToFinishToStartLink(toTask.task, subtaskLink, source, target, fromTask.taskParent, toTask.taskParent));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif(caching)\r\n\t\t\tformattedLinksStash[link.id] = relations;\r\n\r\n\t\treturn relations;\r\n\t};\r\n\r\ngantt._isAutoSchedulable = function(task){\r\n\treturn task.auto_scheduling !== false;\r\n};\r\n\r\ngantt._getImplicitLinks = function(link, parent, selectOffset, selectSourceLinks){\r\n\tvar relations = [];\r\n\r\n\tif(this.isSummaryTask(parent)){\r\n\r\n\t\t// if the summary task contains multiple chains of linked tasks - no need to consider every task of the chain,\r\n\t\t// it will be enough to check the first/last tasks of the chain\r\n\t\t// special conditions if there are unscheduled tasks in the chain, or negative lag values\r\n\t\tvar children = {};\r\n\t\tthis.eachTask(function(c){\r\n\t\t\tif(!this.isSummaryTask(c)){\r\n\t\t\t\tchildren[c.id] = c;\r\n\t\t\t}\r\n\t\t}, parent.id);\r\n\r\n\t\tvar skipChild;\r\n\r\n\t\tfor(var c in children){\r\n\t\t\tvar task = children[c];\r\n\t\t\tvar linksCollection = selectSourceLinks ? task.$source : task.$target;\r\n\r\n\t\t\tskipChild = false;\r\n\r\n\t\t\tfor(var l = 0; l < linksCollection.length; l++){\r\n\t\t\t\tvar siblingLink = gantt.getLink(linksCollection[l]);\r\n\t\t\t\tvar siblingId = selectSourceLinks ? siblingLink.target : siblingLink.source;\r\n\r\n\t\t\t\tif(children[siblingId] && task.auto_scheduling !== false && children[siblingId].auto_scheduling !== false && siblingLink.lag >= 0){\r\n\t\t\t\t\tskipChild = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(!skipChild){\r\n\t\t\t\trelations.push({task: task.id, taskParent: task.parent, lag: selectOffset(task)});\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}else{\r\n\t\trelations.push({task:parent.id, taskParent: parent.parent, lag: 0});\r\n\t}\r\n\r\n\t\treturn relations;\r\n};\r\n\r\n\tgantt._getDirectDependencies = function (task, selectSuccessors) {\r\n\r\n\t\tvar links = [],\r\n\t\t\tsuccessors = [];\r\n\r\n\t\tvar linksIds = selectSuccessors ? task.$source : task.$target;\r\n\r\n\tfor(var i = 0; i < linksIds.length; i++){\r\n\t\tvar link = this.getLink(linksIds[i]);\r\n\t\tif(this.isTaskExists(link.source) && this.isTaskExists(link.target)) {\r\n\t\t\tvar target = this.getTask(link.target);\r\n\t\t\tif(this._isAutoSchedulable(target)){\r\n\t\t\t\tlinks.push(this.getLink(linksIds[i]));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t\tfor (var i = 0; i < links.length; i++) {\r\n\t\t\tsuccessors = successors.concat(this._formatLink(links[i]));\r\n\t\t}\r\n\r\n\t\treturn successors;\r\n\t};\r\n\r\n\tgantt._getInheritedDependencies = function (task, selectSuccessors) {\r\n\r\n\t\t//var successors = [];\r\n\tvar stop = false;\r\n\tvar inheritedRelations = [];\r\n\tvar cacheCollection;\r\n\tif(this.isTaskExists(task.id)){\r\n\r\n\t\tvar parent = this.getParent(task.id);\r\n\r\n\r\n\t\tthis.eachParent(function(parent){\r\n\t\t\tif(stop)\r\n\t\t\t\treturn;\r\n\r\n\t\t\tif(caching){\r\n\t\t\t\tcacheCollection = selectSuccessors ? inheritedSuccessorsStash : inheritedPredecessorsStash;\r\n\t\t\t\tif(cacheCollection[parent.id]){\r\n\t\t\t\t\tinheritedRelations.push.apply(inheritedRelations, cacheCollection[parent.id]);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tvar parentDependencies;\r\n\t\t\tif(this.isSummaryTask(parent)){\r\n\t\t\t\tif(!this._isAutoSchedulable(parent)){\r\n\t\t\t\t\tstop = true;\r\n\t\t\t\t}else{\r\n\t\t\t\t\tparentDependencies = this._getDirectDependencies(parent, selectSuccessors);\r\n\t\t\t\t\tif(caching){\r\n\t\t\t\t\t\tcacheCollection[parent.id] = parentDependencies;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tinheritedRelations.push.apply(inheritedRelations, parentDependencies);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t}, task.id, this);\r\n\r\n\t\t//\tfor (var i = 0; i < inheritedRelations.length; i++) {\r\n\t\t//\t\tsuccessors.push(inheritedRelations[i]);\r\n\t\t//\t}\r\n\t\t}\r\n\r\n\t\treturn inheritedRelations;\r\n\t};\r\n\r\n\r\n\tgantt._getDirectSuccessors = function (task) {\r\n\t\treturn this._getDirectDependencies(task, true);\r\n\t};\r\n\r\n\tgantt._getInheritedSuccessors = function (task) {\r\n\t\treturn this._getInheritedDependencies(task, true);\r\n\t};\r\n\r\n\tgantt._getDirectPredecessors = function (task) {\r\n\t\treturn this._getDirectDependencies(task, false);\r\n\t};\r\n\r\n\tgantt._getInheritedPredecessors = function (task) {\r\n\t\treturn this._getInheritedDependencies(task, false);\r\n\t};\r\n\r\n\tgantt._getSuccessors = function (task, skipInherited) {\r\n\t\tvar successors = this._getDirectSuccessors(task);\r\n\t\tif(skipInherited){\r\n\t\t\treturn successors;\r\n\t\t}else{\r\n\t\t\treturn successors.concat(this._getInheritedSuccessors(task));\r\n\t\t}\r\n\t};\r\n\r\n\tgantt._getPredecessors = function (task, skipInherited) {\r\n\t\tvar key = task.id + skipInherited;\r\n\t\tvar result;\r\n\r\n\t\tif(caching && getPredecessorsCache[key]){\r\n\t\t\treturn getPredecessorsCache[key];\r\n\t\t}\r\n\r\n\t\tvar predecessors = this._getDirectPredecessors(task);\r\n\t\tif(skipInherited){\r\n\t\t\tresult = predecessors;\r\n\t\t}else{\r\n\t\t\tresult = predecessors.concat(this._getInheritedPredecessors(task));\r\n\t\t}\r\n\t\tif(caching){\r\n\t\t\tgetPredecessorsCache[key] = result;\r\n\t\t}\r\n\t\treturn result;\r\n\t};\r\n\r\n\r\n\tgantt._convertToFinishToStartLink = function (id, link, sourceTask, targetTask, sourceParent, targetParent) {\r\n\t\t// convert finish-to-finish, start-to-finish and start-to-start to finish-to-start link and provide some additional properties\r\n\t\tvar res = {\r\n\t\t\ttarget: id,\r\n\t\t\tlink: gantt.config.links.finish_to_start,\r\n\t\t\tid: link.id,\r\n\t\t\tlag: link.lag || 0,\r\n\t\t\tsource: link.source,\r\n\t\t\tpreferredStart: null,\r\n\t\t\tsourceParent: sourceParent,\r\n\t\t\ttargetParent: targetParent\r\n\t\t};\r\n\r\n\t\tvar additionalLag = 0;\r\n\t\tswitch (link.type) {\r\n\t\t\tcase gantt.config.links.start_to_start:\r\n\t\t\t\tadditionalLag = -sourceTask.duration;\r\n\t\t\t\tbreak;\r\n\t\t\tcase gantt.config.links.finish_to_finish:\r\n\t\t\t\tadditionalLag = -targetTask.duration;\r\n\t\t\t\tbreak;\r\n\t\t\tcase gantt.config.links.start_to_finish:\r\n\t\t\t\tadditionalLag = -sourceTask.duration - targetTask.duration;\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tadditionalLag = 0;\r\n\t\t}\r\n\r\n\t\tres.lag += additionalLag;\r\n\t\treturn res;\r\n\t};\r\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/core/links_common.js\n// module id = 1\n// module chunks = 1 3","require(\"../core/links_common\")(gantt);\r\n\r\ngantt.config.highlight_critical_path = false;\r\ngantt._criticalPathHandler = function(){\r\n\tif(gantt.config.highlight_critical_path)\r\n\t\tgantt.render();\r\n};\r\ngantt.attachEvent(\"onAfterLinkAdd\", gantt._criticalPathHandler);\r\ngantt.attachEvent(\"onAfterLinkUpdate\", gantt._criticalPathHandler);\r\ngantt.attachEvent(\"onAfterLinkDelete\", gantt._criticalPathHandler);\r\ngantt.attachEvent(\"onAfterTaskAdd\", gantt._criticalPathHandler);\r\ngantt.attachEvent(\"onAfterTaskUpdate\", gantt._criticalPathHandler);\r\ngantt.attachEvent(\"onAfterTaskDelete\", gantt._criticalPathHandler);\r\n\r\n\r\ngantt._isCriticalTask = function(task, chain){\r\n\tif(!task || !task.id) return;\r\n\tvar path = chain || {};\r\n\r\n\tif(this._isProjectEnd(task)){\r\n\t\treturn true;\r\n\t}else{\r\n\r\n\t\tvar clearCache = false;\r\n\t\tif(!gantt._isLinksCacheEnabled()) {\r\n\t\t\tgantt._startLinksCache();\r\n\t\t\tclearCache = true;\r\n\t\t}\r\n\r\n\t\tpath[task.id] = true;\r\n\t\tvar successors = this._getDependencies(task);\r\n\t\tfor(var i=0; i < successors.length; i++){\r\n\t\t\tvar next = this.getTask(successors[i].target);\r\n\t\t\tif(this._getSlack(task, next, successors[i]) <= 0 && (!path[next.id] && this._isCriticalTask(next, path)))\r\n\t\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tif(clearCache)\r\n\t\t\tgantt._endLinksCache();\r\n\t}\r\n\r\n\treturn false;\r\n};\r\n\r\ngantt.isCriticalTask = function (task) {\r\n\tgantt.assert(!!(task && task.id !== undefined), \"Invalid argument for gantt.isCriticalTask\");\r\n\treturn this._isCriticalTask(task, {});\r\n};\r\n\r\ngantt.isCriticalLink = function (link) {\r\n\treturn this.isCriticalTask(gantt.getTask(link.source));\r\n};\r\n\r\ngantt.getSlack = function(task1, task2){\r\n\tvar relations = [];\r\n\tvar common = {};\r\n\tfor(var i=0; i < task1.$source.length; i++){\r\n\t\tcommon[task1.$source[i]] = true;\r\n\t}\r\n\tfor(var i=0; i < task2.$target.length; i++){\r\n\t\tif(common[task2.$target[i]])\r\n\t\t\trelations.push(task2.$target[i]);\r\n\t}\r\n\r\n\tvar slacks = [];\r\n\tfor(var i=0; i < relations.length; i++){\r\n\t\tvar link = this.getLink(relations[i]);\r\n\t\tslacks.push(this._getSlack(task1, task2, this._convertToFinishToStartLink(link.id, link, task1, task2, task1.parent, task2.parent)));\r\n\t}\r\n\r\n\treturn Math.min.apply(Math, slacks);\r\n};\r\n\r\ngantt._getSlack = function (task, next_task, relation) {\r\n\t// relation - link expressed as finish-to-start (gantt._convertToFinishToStartLink)\r\n\tvar types = this.config.types;\r\n\r\n\tvar from = null;\r\n\tif(this.getTaskType(task.type) == types.milestone){\r\n\t\tfrom = task.start_date;\r\n\t}else{\r\n\t\tfrom = task.end_date;\r\n\t}\r\n\r\n\tvar to = next_task.start_date;\r\n\r\n\tvar duration = 0;\r\n\tif(+from > +to){\r\n\t\tduration = -this.calculateDuration({start_date: to, end_date: from, task: task});\r\n\t}else{\r\n\t\tduration = this.calculateDuration({start_date: from, end_date: to, task: task});\r\n\t}\r\n\r\n\tvar lag = relation.lag;\r\n\tif(lag && lag*1 == lag){\r\n\t\tduration -= lag;\r\n\t}\r\n\r\n\treturn duration;\r\n};\r\n\r\ngantt._getProjectEnd = function () {\r\n\tvar tasks = gantt.getTaskByTime();\r\n\ttasks = tasks.sort(function (a, b) { return +a.end_date > +b.end_date ? 1 : -1; });\r\n\treturn tasks.length ? tasks[tasks.length - 1].end_date : null;\r\n};\r\n\r\ngantt._isProjectEnd = function (task) {\r\n\treturn !(this._hasDuration({start_date:task.end_date, end_date: this._getProjectEnd(), task:task}));\r\n};\r\n\r\ngantt._getSummaryPredecessors = function(task){\r\n\tvar predecessors = [];\r\n\r\n\t// all constraints that are applied to summary parents must be applied to the task\r\n\tthis.eachParent(function(parent){\r\n\t\tif(this.isSummaryTask(parent))\r\n\t\t\tpredecessors = predecessors.concat(gantt._getDependencies(parent));\r\n\t}, task);\r\n\r\n\treturn predecessors;\r\n};\r\n\r\n\r\ngantt._getDependencies = function(task){\r\n\tvar successors = this._getSuccessors(task).concat(\r\n\t\tthis._getSummaryPredecessors(task)\r\n\t);\r\n\treturn successors;\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/ext/critical_path.js\n// module id = 6\n// module chunks = 3"],"sourceRoot":""}